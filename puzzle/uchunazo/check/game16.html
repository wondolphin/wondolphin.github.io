<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>テン×テン</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* フォントや全体的なスタイルを設定 */
        body {
            font-family: 'Hiragino Sans', 'Meiryo', sans-serif;
            touch-action: none; /* スマホでのダブルタップによるズームを防止 */
            overscroll-behavior: none; /* スクロールによる画面のバウンスを防止 */
        }
        canvas {
            cursor: pointer;
        }
        /* スコアの色の変化を滑らかにするためのトランジション */
        #score {
            transition: color 0.3s ease-in-out;
        }
        /* クリア画面のスタイル */
        #clearOverlay {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }
        #clearText {
            animation: fadeIn 0.5s ease-out, popUp 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes popUp {
            from { transform: scale(0.5); }
            to { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center h-screen overflow-hidden">

    <div class="w-full h-full mx-auto text-center relative flex flex-col p-2">
        
        <!-- ヘッダーエリア (タイトル & スコア) -->
        <div class="flex-shrink-0" id="header">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-800">テン×テン</h1>
            <div class="bg-white rounded-lg shadow-lg p-2 my-2">
                <p id="score" class="text-4xl font-bold">0</p>
                <!-- スコアゲージ -->
                <div class="w-full h-2 sm:h-3 mt-2">
                    <div id="scoreGauge" class="h-full rounded-full mx-auto" style="width: 0%; transition: width 0.5s ease-out, background-color 0.3s ease-in-out;"></div>
                </div>
            </div>
        </div>

        <!-- ゲームの描画エリア (可変) -->
        <div class="flex-1 w-full flex items-center justify-center min-h-0">
             <div id="game-container" class="aspect-square bg-white rounded-lg shadow-xl overflow-hidden">
                <canvas id="gameCanvas" class="w-full h-full"></canvas>
            </div>
        </div>

        <!-- クリア表示用のオーバーレイ -->
        <div id="clearOverlay" class="absolute inset-0 z-10 hidden items-center justify-center cursor-pointer">
            <h2 id="clearText" class="text-7xl font-extrabold text-white" style="text-shadow: 0 0 15px #f6e05e, 0 0 25px #f6e05e;">CLEAR!</h2>
        </div>

    </div>

    <script>
        // DOM要素の取得
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const scoreGauge = document.getElementById('scoreGauge');
        const clearOverlay = document.getElementById('clearOverlay');
        const header = document.getElementById('header');
        const gameContainer = document.getElementById('game-container');
        const mainContainer = document.querySelector('.w-full.h-full');

        // ゲームの設定
        const NUM_SWITCHES = 10;
        const SWITCH_RADIUS_RATIO = 0.06;
        const CIRCLE_RADIUS_RATIO = 0.38;
        const MAX_GAUGE_SCORE = 30;
        const ANIMATION_DURATION = 250; // アニメーションの時間 (ミリ秒)

        // ゲームの状態
        let numbers = [0, 7, 1, 8, 6, 2, 9, 4, 3, 5]; 
        let switchPositions = [];
        let selectedPositionIndex = -1;
        let secondSelectedIndex = -1;
        let canvasSize = 0;
        let switchRadius = 0;
        let isGameCleared = false;
        let linesUnlocked = false; // 一度でもクリアしたかを記録するフラグ
        let isAnimating = false;
        let animationStartTime = 0;
        
        // 初期化処理
        function init() {
            // ヘッダーの高さを考慮してゲームコンテナの最大サイズを動的に設定
            const headerHeight = header.offsetHeight;
            const mainPadding = parseFloat(getComputedStyle(mainContainer).paddingTop) * 2;
            
            const availableHeight = window.innerHeight - headerHeight - mainPadding;
            const availableWidth = window.innerWidth - mainPadding;
            
            const size = Math.min(availableWidth, availableHeight);
            gameContainer.style.width = `${size}px`;
            gameContainer.style.height = `${size}px`;

            canvasSize = Math.min(gameContainer.clientWidth, gameContainer.clientHeight);
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            switchRadius = canvasSize * SWITCH_RADIUS_RATIO;
            calculateSwitchPositions();
            draw();
        }

        function calculateSwitchPositions() {
            switchPositions = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const circleRadius = canvasSize * CIRCLE_RADIUS_RATIO;
            for (let i = 0; i < NUM_SWITCHES; i++) {
                const angle = (i / NUM_SWITCHES) * 2 * Math.PI - Math.PI / 2;
                const x = centerX + circleRadius * Math.cos(angle);
                const y = centerY + circleRadius * Math.sin(angle);
                switchPositions.push({ x, y });
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const lines = calculateLines();
            const intersectionPoints = calculateIntersections(lines);
            const intersectionCount = intersectionPoints.size;
            
            updateScoreUI(intersectionCount);

            if (intersectionCount === 0) {
                // スコアが0で、まだこの盤面でクリア判定されていない場合
                if (!isGameCleared) {
                    isGameCleared = true; // この盤面はクリア済みとマーク
                    linesUnlocked = true; // 線を永続的にアンロック
                    setTimeout(() => {
                        if (clearOverlay) {
                            clearOverlay.classList.remove('hidden');
                            clearOverlay.classList.add('flex');
                        }
                    }, 800);
                }
            } else {
                // スコアが0でなければ、クリア状態ではない
                isGameCleared = false;
            }

            // 線がアンロックされている場合に線を描画する
            if (linesUnlocked) {
                drawConnectingLines(lines);
            }

            // 赤い点を描画する (線の上に来るように)
            drawIntersections(intersectionPoints);

            drawSwitches();
        }
        
        function drawConnectingLines(lines) {
            ctx.strokeStyle = '#a0aec0'; // gray-400
            ctx.lineWidth = Math.max(1, canvasSize * 0.005);
            lines.forEach(line => {
                ctx.beginPath();
                ctx.moveTo(line.p1.x, line.p1.y);
                ctx.lineTo(line.p2.x, line.p2.y);
                ctx.stroke();
            });
        }
        
        function drawIntersections(intersectionPoints) {
            ctx.fillStyle = '#e53e3e'; // red-600
            const radius = Math.max(2, canvasSize * 0.008);
            for (const point of intersectionPoints.values()) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function calculateLines() {
            const numberPositions = new Array(NUM_SWITCHES);
            numbers.forEach((num, posIndex) => { numberPositions[num] = posIndex; });
            const lines = [];
            for (let i = 0; i < NUM_SWITCHES; i++) {
                const startNum = i;
                const endNum = (i + 1) % NUM_SWITCHES;
                const startPosIndex = numberPositions[startNum];
                const endPosIndex = numberPositions[endNum];
                if (startPosIndex !== undefined && endPosIndex !== undefined) {
                    lines.push({
                        p1: switchPositions[startPosIndex],
                        p2: switchPositions[endPosIndex],
                        nums: [startNum, endNum].sort((a,b) => a-b)
                    });
                }
            }
            return lines;
        }

        function interpolateColor(color1, color2, factor) {
            let r1 = parseInt(color1.substring(1, 3), 16), g1 = parseInt(color1.substring(3, 5), 16), b1 = parseInt(color1.substring(5, 7), 16);
            let r2 = parseInt(color2.substring(1, 3), 16), g2 = parseInt(color2.substring(3, 5), 16), b2 = parseInt(color2.substring(5, 7), 16);
            let r = Math.round(r1 + factor * (r2 - r1)), g = Math.round(g1 + factor * (g2 - g1)), b = Math.round(b1 + factor * (b2 - b1));
            return `rgb(${r}, ${g}, ${b})`;
        }

        function getScoreColor(score) {
            const colors = { red: '#ef4444', orange: '#f97316', yellow: '#eab308', green: '#22c55e' };
            if (score >= 16) return colors.red;
            if (score >= 12) return interpolateColor(colors.orange, colors.red, (score - 12) / 4);
            if (score >= 6) return interpolateColor(colors.yellow, colors.orange, (score - 6) / 6);
            if (score > 0) return interpolateColor(colors.green, colors.yellow, score / 6);
            return colors.green;
        }
        
        function updateScoreUI(score) {
            scoreElement.textContent = score;
            const color = getScoreColor(score);
            scoreElement.style.color = color;
            const gaugeWidth = Math.min(100, (score / MAX_GAUGE_SCORE) * 100);
            scoreGauge.style.width = `${gaugeWidth}%`;
            scoreGauge.style.backgroundColor = color;
        }

        function drawSwitches(animationProgress = 1) {
             switchPositions.forEach((pos, i) => {
                let currentPos = { x: pos.x, y: pos.y };

                // アニメーション中の場合、座標を補間する
                if (isAnimating) {
                    const easeProgress = 0.5 - 0.5 * Math.cos(animationProgress * Math.PI); // イーズイン・アウト
                    if (i === selectedPositionIndex) {
                        const targetPos = switchPositions[secondSelectedIndex];
                        currentPos.x = pos.x + (targetPos.x - pos.x) * easeProgress;
                        currentPos.y = pos.y + (targetPos.y - pos.y) * easeProgress;
                    } else if (i === secondSelectedIndex) {
                        const targetPos = switchPositions[selectedPositionIndex];
                        currentPos.x = pos.x + (targetPos.x - pos.x) * easeProgress;
                        currentPos.y = pos.y + (targetPos.y - pos.y) * easeProgress;
                    }
                }

                // スイッチの円を描画
                ctx.beginPath();
                if (i === selectedPositionIndex || i === secondSelectedIndex) {
                    ctx.fillStyle = '#63b3ed'; ctx.strokeStyle = '#2b6cb0';
                    ctx.lineWidth = Math.max(2, canvasSize * 0.008);
                } else {
                    ctx.fillStyle = 'white'; ctx.strokeStyle = '#4a5568';
                    ctx.lineWidth = Math.max(1, canvasSize * 0.005);
                }
                ctx.arc(currentPos.x, currentPos.y, switchRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            });
        }
        
        function calculateIntersections(lines) {
            const intersectionPoints = new Map();
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 1; j < lines.length; j++) {
                    const line1 = lines[i]; const line2 = lines[j];
                    if (line1.nums.includes(line2.nums[0]) || line1.nums.includes(line2.nums[1])) continue;
                    const p = getLineIntersection(line1.p1, line1.p2, line2.p1, line2.p2);
                    if (p) {
                        const key = `${Math.round(p.x)},${Math.round(p.y)}`;
                        if (!intersectionPoints.has(key)) {
                             intersectionPoints.set(key, p);
                        }
                    }
                }
            }
            return intersectionPoints;
        }

        function getLineIntersection(p1, p2, p3, p4) {
            const d = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
            if (d === 0) return null;
            const t = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / d;
            const u = -((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)) / d;
            const e = 1e-6;
            if (t > e && t < 1 - e && u > e && u < 1 - e) {
                return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
            }
            return null;
        }
        
        function animationLoop(timestamp) {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsed = timestamp - animationStartTime;
            const progress = Math.min(elapsed / ANIMATION_DURATION, 1);

            // 描画処理
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const lines = calculateLines();
            const intersectionPoints = calculateIntersections(lines);
            
            // 線がアンロックされていれば、アニメーション中も線を描画
            if (linesUnlocked) {
                drawConnectingLines(lines);
            }

            // 赤い点を描画
            drawIntersections(intersectionPoints);
            
            drawSwitches(progress); // スイッチをアニメーションさせて描画

            if (progress < 1) {
                requestAnimationFrame(animationLoop);
            } else {
                // アニメーション終了処理
                [numbers[selectedPositionIndex], numbers[secondSelectedIndex]] = 
                [numbers[secondSelectedIndex], numbers[selectedPositionIndex]];
                
                selectedPositionIndex = -1;
                secondSelectedIndex = -1;
                isAnimating = false;
                draw(); // 最終状態を再描画
            }
        }

        canvas.addEventListener('pointerdown', (e) => {
            if (isAnimating || (clearOverlay && !clearOverlay.classList.contains('hidden'))) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            let clickedPositionIndex = -1;
            switchPositions.forEach((pos, i) => {
                const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                if (dist < switchRadius) clickedPositionIndex = i;
            });

            if (clickedPositionIndex !== -1) {
                if (selectedPositionIndex === -1) {
                    selectedPositionIndex = clickedPositionIndex;
                    draw();
                } else {
                    if (selectedPositionIndex !== clickedPositionIndex) {
                        isAnimating = true;
                        secondSelectedIndex = clickedPositionIndex;
                        animationStartTime = 0;
                        requestAnimationFrame(animationLoop);
                    } else {
                        selectedPositionIndex = -1;
                        draw();
                    }
                }
            }
        });
        
        clearOverlay.addEventListener('click', () => {
            clearOverlay.classList.add('hidden');
            clearOverlay.classList.remove('flex');
        });

        window.addEventListener('resize', init);
        
        setTimeout(init, 0);
    </script>
</body>
</html>

