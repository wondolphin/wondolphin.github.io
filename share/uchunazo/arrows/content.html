<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>さしつさされつ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* カスタムスタイルで滑らかなアニメーションと見やすいデザインを定義します */
        body {
            font-family: 'Inter', 'Helvetica Neue', 'Arial', sans-serif;
            touch-action: manipulation; /* ダブルタップによるズームを無効化 */
        }

        /* --- ランプのスタイル --- */
        .lamp {
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            border: 2px solid #4b5563; /* gray-600 */
        }
        .lamp .circle {
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            background-color: #4b5563; /* gray-600 */
        }
        
        /* ランプの発光色 (緑色に統一) */
        .lamp.on-border-green {
            border-color: #4ade80; /* green-400 */
            box-shadow: 0 0 8px #22c55e; /* green-500 */
        }
        .lamp .circle.on-green {
            background-color: #4ade80; /* green-400 */
            box-shadow: 0 0 10px #22c55e; /* green-500 */
        }

        /* --- 矢印のスタイル --- */
        .arrow {
            transition: transform 0.2s ease, color 0.3s ease-out, box-shadow 0.3s ease-out, outline 0.2s ease;
            cursor: pointer;
            border-radius: 0.5rem; /* rounded-lg */
        }
        .arrow:hover {
            transform: scale(1.1);
        }

        /* 枠の発光 (指されている数) */
        .border-glow-blue { box-shadow: 0 0 12px 3px rgba(96, 165, 250, 0.8); } /* blue-400 */
        .border-glow-green { box-shadow: 0 0 12px 3px rgba(74, 222, 128, 0.8); } /* green-400 */
        .border-glow-orange { box-shadow: 0 0 12px 3px rgba(251, 146, 60, 0.8); } /* orange-400 */

        /* 選択中のハイライト */
        .selected {
            outline: 3px solid #fde047; /* yellow-300 */
            outline-offset: 2px;
            transform: scale(1.1);
        }

        /* クリアメッセージ */
        @keyframes pulse-text {
            0%, 100% { transform: scale(1); text-shadow: 0 0 20px #facc15; }
            50% { transform: scale(1.05); text-shadow: 0 0 30px #fde047, 0 0 40px #facc15; }
        }
        #clear-modal h2 { animation: pulse-text 2s infinite; }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased">

    <div id="app" class="container mx-auto p-4 flex flex-col items-center min-h-screen justify-center space-y-6">
        
        <h1 class="text-4xl md:text-5xl font-bold text-gray-200 tracking-wider">さしつさされつ</h1>

        <!-- ランプエリア -->
        <div id="lamps-container" class="flex flex-wrap justify-center gap-2 md:gap-3">
            <!-- ランプはJSで生成されます -->
        </div>

        <!-- 盤面 -->
        <div id="board-container" class="grid grid-cols-4 gap-2 bg-gray-800/50 p-2 rounded-lg shadow-lg">
            <!-- 盤面のセルはJSで生成されます -->
        </div>

        <!-- スタンバイエリア -->
        <div id="standby-area-wrapper" class="w-full max-w-xl bg-gray-800/50 p-3 rounded-lg shadow-lg">
            <div id="standby-area" class="h-40 flex flex-wrap content-start gap-2 justify-center rounded-md border-2 border-dashed border-gray-700 p-2">
                <!-- スタンバイの矢印はJSで生成されます -->
            </div>
        </div>

        <div id="clear-modal" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center cursor-pointer z-50">
            <h2 class="text-6xl sm:text-8xl md:text-9xl font-bold text-yellow-300">CLEAR!</h2>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const BOARD_SIZE = 4;
            const LAMP_COUNT = 14;
            const INITIAL_ARROWS = { up: 3, down: 3, left: 4, right: 4 };

            const lampsContainer = document.getElementById('lamps-container');
            const boardContainer = document.getElementById('board-container');
            const standbyArea = document.getElementById('standby-area');
            const clearModal = document.getElementById('clear-modal');

            let boardState = Array(BOARD_SIZE * BOARD_SIZE).fill(null);
            let standbyArrows = [];
            let selected = null;

            const arrowSVGs = {
                up: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2L4,10c-0.6,0.6,0,1.5,0.8,1.5h4.2v8.5c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1V11.5h4.2c0.8,0,1.4-0.9,0.8-1.5L12,2Z"/></svg>`,
                down: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="currentColor"><path d="M12,22L20,14c0.6-0.6,0-1.5-0.8-1.5H15V4c0-0.6-0.4-1-1-1h-4c-0.6,0-1,0.4-1,1v8.5H4.8c-0.8,0-1.4,0.9-0.8,1.5L12,22Z"/></svg>`,
                left: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="currentColor"><path d="M2,12l8,8c0.6,0.6,1.5,0,1.5-0.8V15h8.5c0.6,0,1-0.4,1-1v-4c0-0.6-0.4-1-1-1H11.5V4.8c0-0.8-0.9-1.4-1.5-0.8L2,12Z"/></svg>`,
                right: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="currentColor"><path d="M22,12l-8-8c-0.6-0.6-1.5,0-1.5,0.8V9H4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h8.5v4.2c0,0.8,0.9,1.4,1.5,0.8L22,12Z"/></svg>`,
            };

            function init() {
                standbyArrows = [];
                Object.entries(INITIAL_ARROWS).forEach(([dir, count]) => {
                    for (let i = 0; i < count; i++) standbyArrows.push(dir);
                });

                lampsContainer.innerHTML = '';
                for (let i = 0; i < LAMP_COUNT; i++) {
                    const lamp = document.createElement('div');
                    lamp.className = 'lamp w-9 h-9 md:w-10 md:h-10 bg-gray-800 rounded-lg flex items-center justify-center';
                    const circle = document.createElement('div');
                    circle.className = 'circle w-5 h-5 md:w-6 md:h-6 rounded-full';
                    lamp.appendChild(circle);
                    lampsContainer.appendChild(lamp);
                }

                boardContainer.innerHTML = '';
                for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell w-16 h-16 md:w-20 md:h-20 bg-gray-900/50 rounded-lg flex items-center justify-center';
                    cell.dataset.index = i;
                    cell.addEventListener('click', () => handleBoardCellClick(i));
                    boardContainer.appendChild(cell);
                }

                renderStandby();
                updateGame();

                standbyArea.addEventListener('click', handleStandbyAreaClick);
                clearModal.addEventListener('click', () => clearModal.classList.add('hidden'));
            }

            function renderStandby() {
                standbyArea.innerHTML = '';
                const sortOrder = { 'up': 1, 'right': 2, 'down': 3, 'left': 4 };
                standbyArrows.sort((a, b) => sortOrder[a] - sortOrder[b]);

                standbyArrows.forEach((direction, index) => {
                    const arrow = createArrowElement(direction);
                    arrow.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handleStandbyArrowClick(index, direction, arrow);
                    });
                    standbyArea.appendChild(arrow);
                });
            }

            function renderBoard() {
                const cells = boardContainer.children;
                for (let i = 0; i < cells.length; i++) {
                    cells[i].innerHTML = '';
                    const arrowData = boardState[i];
                    if (arrowData) {
                        const arrow = createArrowElement(arrowData.direction);
                        if (arrowData.borderColor) {
                            arrow.classList.add(`border-glow-${arrowData.borderColor}`);
                        }
                        if (arrowData.innerColor) {
                            arrow.classList.remove('text-gray-400');
                            const colorMap = {
                                blue: 'text-blue-400',
                                green: 'text-green-400',
                                orange: 'text-orange-400'
                            };
                            arrow.classList.add(colorMap[arrowData.innerColor]);
                        }
                        cells[i].appendChild(arrow);
                    }
                }
                if (selected && selected.type === 'board') {
                    const selectedArrow = boardContainer.children[selected.index]?.querySelector('.arrow');
                    if (selectedArrow) {
                        selectedArrow.classList.add('selected');
                        selected.element = selectedArrow;
                    }
                }
            }

            function createArrowElement(direction) {
                const div = document.createElement('div');
                div.className = 'arrow w-12 h-12 md:w-16 md:h-16 text-gray-400 p-1 border border-gray-700';
                div.innerHTML = arrowSVGs[direction];
                return div;
            }

            function updateLamps(greenBorderCount, greenInnerCount) {
                const lamps = lampsContainer.children;
                for (let i = 0; i < lamps.length; i++) {
                    const lamp = lamps[i];
                    const circle = lamp.querySelector('.circle');

                    lamp.classList.toggle('on-border-green', i < greenBorderCount);
                    if (circle) {
                        circle.classList.toggle('on-green', i < greenInnerCount);
                    }
                }
            }
            
            function setSelected(newSelected) {
                if (selected && selected.element) selected.element.classList.remove('selected');
                selected = newSelected;
                if (selected && selected.element) selected.element.classList.add('selected');
            }

            function handleStandbyArrowClick(index, direction, element) {
                if (selected && selected.type === 'standby' && selected.index === index) {
                    setSelected(null);
                } else {
                    setSelected({ type: 'standby', index, direction, element });
                }
            }
            
            function handleBoardCellClick(index) {
                const clickedCellState = boardState[index];
                const clickedCellArrowElement = boardContainer.children[index].querySelector('.arrow');

                if (selected) {
                    if (selected.type === 'standby') {
                        const arrowToMove = standbyArrows.splice(selected.index, 1)[0];
                        if (clickedCellState) standbyArrows.push(clickedCellState.direction);
                        boardState[index] = { direction: arrowToMove };
                        setSelected(null);
                        renderStandby();
                        updateGame();
                    } else { // 'board' selected
                        if (selected.index === index) {
                            setSelected(null);
                        } else {
                            [boardState[index], boardState[selected.index]] = [boardState[selected.index], boardState[index]];
                            setSelected(null);
                            updateGame();
                        }
                    }
                } else {
                    if (clickedCellState) {
                        setSelected({ type: 'board', index, direction: clickedCellState.direction, element: clickedCellArrowElement });
                    }
                }
            }

            function handleStandbyAreaClick() {
                if (selected && selected.type === 'board') {
                    standbyArrows.push(boardState[selected.index].direction);
                    boardState[selected.index] = null;
                    setSelected(null);
                    renderStandby();
                    updateGame();
                }
            }

            function updateGame() {
                let arrowsOnBoard = [];
                boardState.forEach((arrow, index) => {
                    if (arrow) {
                        arrowsOnBoard.push({
                            ...arrow,
                            row: Math.floor(index / BOARD_SIZE), col: index % BOARD_SIZE, index: index,
                            pointedBy: 0, pointingAt: 0,
                        });
                    }
                });

                for (const pointer of arrowsOnBoard) {
                    for (const target of arrowsOnBoard) {
                        if (pointer.index === target.index) continue;
                        if (isPointing(pointer, target)) {
                            pointer.pointingAt++;
                            target.pointedBy++;
                        }
                    }
                }

                let greenBorderCount = 0;
                let greenInnerCount = 0;

                arrowsOnBoard.forEach(arrow => {
                    const state = boardState[arrow.index];
                    state.borderColor = getColor(arrow.pointedBy);
                    state.innerColor = getColor(arrow.pointingAt);

                    if (state.borderColor === 'green') {
                        greenBorderCount++;
                    }
                    if (state.innerColor === 'green') {
                        greenInnerCount++;
                    }
                });

                renderBoard();
                updateLamps(greenBorderCount, greenInnerCount);

                if (greenBorderCount === LAMP_COUNT && greenInnerCount === LAMP_COUNT && arrowsOnBoard.length > 0) {
                    setTimeout(() => clearModal.classList.remove('hidden'), 500);
                }
            }

            function getColor(count) {
                if (count === 1) return 'blue';
                if (count === 2) return 'green';
                if (count >= 3) return 'orange';
                return null;
            }
            
            function isPointing(pointer, target) {
                switch (pointer.direction) {
                    case 'up': return pointer.col === target.col && pointer.row > target.row;
                    case 'down': return pointer.col === target.col && pointer.row < target.row;
                    case 'left': return pointer.row === target.row && pointer.col > target.col;
                    case 'right': return pointer.row === target.row && pointer.col < target.col;
                    default: return false;
                }
            }

            init();
        });
    </script>
</body>
</html>

