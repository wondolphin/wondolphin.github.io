<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シミュレーション・ハッカー - Visual Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        
        body {
            background-color: #050508;
            color: #00ff41;
            font-family: 'Share+Tech+Mono', monospace;
            overflow-x: hidden;
            user-select: none;
        }

        .hacker-border {
            border: 1px solid #00ff41;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.15);
        }

        .glow-text {
            text-shadow: 0 0 8px rgba(0, 255, 65, 0.8);
        }

        /* スロット色定義 */
        .slot-a { color: #3b82f6; border-color: #3b82f6 !important; } /* Blue */
        .slot-b { color: #fbbf24; border-color: #fbbf24 !important; } /* Amber */
        .slot-c { color: #ec4899; border-color: #ec4899 !important; } /* Pink */
        
        .bg-slot-a { background-color: #3b82f6; }
        .bg-slot-b { background-color: #fbbf24; }
        .bg-slot-c { background-color: #ec4899; }

        .chip-btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(0, 255, 65, 0.2);
            transition: all 0.2s ease;
        }

        .chip-btn:hover:not(:disabled) {
            background: rgba(0, 255, 65, 0.15);
            border-color: #00ff41;
            transform: translateY(-2px);
        }

        #pattern-visualizer {
            display: grid;
            grid-template-columns: repeat(50, 1fr);
            gap: 1px;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px;
            border-radius: 2px;
        }

        .dot {
            width: 4px; height: 4px;
            background-color: #111;
            transition: all 0.4s ease;
        }

        .dot.active {
            background-color: #00ff41;
            box-shadow: 0 0 3px #00ff41;
        }

        .dot.target-lost {
            background-color: #400;
        }

        #matrix-bg {
            position: fixed;
            top: 0; left: 0; z-index: -1;
            opacity: 0.1;
        }

        .condition-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            font-weight: bold;
            color: black;
            font-size: 14px;
            margin-right: 4px;
        }

        .applied-badge {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 6px 10px;
            margin-bottom: 6px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            border-radius: 4px;
        }

        @keyframes success-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 30px #00ff41; }
            100% { transform: scale(1); }
        }

        .success-node { animation: success-pulse 0.6s ease-in-out; }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <canvas id="matrix-bg"></canvas>

    <div id="game-container" class="max-w-5xl w-full hacker-border bg-black/95 p-6 rounded-xl relative overflow-hidden flex flex-col lg:flex-row gap-8">
        
        <!-- Left Side: Visualization -->
        <div class="flex-1 flex flex-col gap-6">
            <div class="flex justify-between items-end border-b border-green-500/30 pb-2">
                <div>
                    <h1 class="text-xl font-bold glow-text tracking-tighter">DECRYPT_ENGINE v3.0</h1>
                    <div id="level-display" class="text-[10px] opacity-50">STG: 1/5</div>
                </div>
                <div id="match-percent" class="text-[10px] text-green-500/50">1000 / 1000 ACTIVE</div>
            </div>

            <!-- Pattern Grid -->
            <div class="bg-black border border-white/5 p-2 rounded">
                <div id="pattern-visualizer"></div>
            </div>

            <!-- Stats Bar -->
            <div class="grid grid-cols-3 gap-2">
                <div class="bg-white/5 p-3 rounded text-center border border-white/10">
                    <div class="text-[9px] opacity-40">CURRENT</div>
                    <div id="current-count" class="text-2xl font-bold">1000</div>
                </div>
                <div class="flex items-center justify-center text-xl opacity-20">⇒</div>
                <div class="bg-blue-900/10 p-3 rounded text-center border border-blue-500/30">
                    <div class="text-[9px] text-blue-400/60">TARGET</div>
                    <div id="target-count" class="text-2xl font-bold text-blue-400">100</div>
                </div>
            </div>

            <!-- Current Filters -->
            <div class="bg-white/5 p-4 rounded-lg border border-white/10 flex-1">
                <div class="text-[10px] uppercase mb-3 opacity-30 tracking-widest">Active Filters</div>
                <div id="applied-chips-list" class="flex flex-col gap-1"></div>
            </div>
        </div>

        <!-- Right Side: Controls -->
        <div class="w-full lg:w-80 flex flex-col gap-6 border-l border-white/5 pl-0 lg:pl-8">
            
            <!-- Slots Visual -->
            <div class="flex justify-between gap-2 p-4 bg-black rounded-lg border border-white/10">
                <div class="flex-1 text-center">
                    <div class="text-[8px] opacity-30 mb-1">A</div>
                    <div id="slot-a-val" class="h-10 w-full flex items-center justify-center border-2 rounded slot-a text-xl font-bold">?</div>
                </div>
                <div class="flex-1 text-center">
                    <div class="text-[8px] opacity-30 mb-1">B</div>
                    <div id="slot-b-val" class="h-10 w-full flex items-center justify-center border-2 rounded slot-b text-xl font-bold">?</div>
                </div>
                <div class="flex-1 text-center">
                    <div class="text-[8px] opacity-30 mb-1">C</div>
                    <div id="slot-c-val" class="h-10 w-full flex items-center justify-center border-2 rounded slot-c text-xl font-bold">?</div>
                </div>
            </div>

            <!-- Choice Buttons -->
            <div class="flex-1">
                <div class="text-[10px] uppercase mb-4 opacity-50 tracking-widest">Select Logic Patch</div>
                <div id="choices-container" class="flex flex-col gap-3"></div>
            </div>

            <!-- Console Message -->
            <div id="message-box" class="p-4 bg-black border border-white/10 rounded-lg text-xs min-h-[80px] flex items-center leading-relaxed">
                SYSTEM READY...
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="result-modal" class="fixed inset-0 bg-black/98 z-50 flex items-center justify-center hidden p-6">
        <div class="text-center p-12 hacker-border rounded-2xl bg-black max-w-md w-full">
            <div class="text-6xl mb-6">✔</div>
            <h2 class="text-3xl font-bold glow-text mb-2">HACKED</h2>
            <p class="text-xs mb-8 opacity-50">DATABASE ACCESSED SUCCESSFULLY</p>
            <button onclick="resetGame()" class="w-full py-4 rounded-lg border border-green-500 font-bold hover:bg-green-500 hover:text-black transition-all">REBOOT</button>
        </div>
    </div>

    <script>
        // Slot Colors
        const SLOT_COLORS = { a: 'bg-slot-a', b: 'bg-slot-b', c: 'bg-slot-c' };

        const levels = [
            {
                start: 1000,
                target: 100,
                slots: ['?', '?', '?'],
                applied: [{ type: 'range', slot: 'all', val: '0-9' }],
                check: (n) => true,
                choices: [
                    { type: 'equal', slot: 'a', val: '7', factor: 0.1, check: (n) => Math.floor(n/100) === 7 },
                    { type: 'set', slot: 'a', val: '{0,2,4,6,8}', factor: 0.5, check: (n) => Math.floor(n/100) % 2 === 0 },
                    { type: 'equal', slot: 'b', val: '0', factor: 0.1, check: (n) => Math.floor((n%100)/10) === 0 }
                ],
                correctIndex: [0, 2]
            },
            {
                start: 100,
                target: 50,
                slots: ['7', '?', '?'],
                applied: [{ type: 'equal', slot: 'a', val: '7' }],
                check: (n) => Math.floor(n/100) === 7,
                choices: [
                    { type: 'set', slot: 'b', val: '{1,2,3,4,5}', factor: 0.5, check: (n) => {
                        const b = Math.floor((n%100)/10);
                        return Math.floor(n/100) === 7 && b >= 1 && b <= 5;
                    }},
                    { type: 'set', slot: 'c', val: '{1,3,5,7,9}', factor: 0.5, check: (n) => {
                        return Math.floor(n/100) === 7 && (n % 10) % 2 !== 0;
                    }},
                    { type: 'equal', slot: 'b', val: '2', factor: 0.1, check: (n) => Math.floor(n/100) === 7 && Math.floor((n%100)/10) === 2 }
                ],
                correctIndex: [0, 1]
            },
            {
                start: 720,
                target: 72,
                slots: ['?', '?', '?'],
                applied: [{ type: 'not-equal', slot: 'all', val: 'A≠B≠C' }],
                check: (n) => {
                    const a = Math.floor(n/100), b = Math.floor((n%100)/10), c = n%10;
                    return a !== b && b !== c && a !== c;
                },
                choices: [
                    { type: 'equal', slot: 'a', val: '0', factor: 0.1, check: (n) => {
                        const a = Math.floor(n/100), b = Math.floor((n%100)/10), c = n%10;
                        return a === 0 && a !== b && b !== c && a !== c;
                    }},
                    { type: 'set', slot: 'c', val: '{0,2,4,6,8}', factor: 0.5, check: (n) => {
                        const a = Math.floor(n/100), b = Math.floor((n%100)/10), c = n%10;
                        return c % 2 === 0 && a !== b && b !== c && a !== c;
                    }},
                    { type: 'set', slot: 'b', val: '{1,2}', factor: 0.2, check: (n) => {
                        const a = Math.floor(n/100), b = Math.floor((n%100)/10), c = n%10;
                        return (b === 1 || b === 2) && a !== b && b !== c && a !== c;
                    }}
                ],
                correctIndex: [0]
            },
            {
                start: 1000,
                target: 200,
                slots: ['?', '?', '?'],
                applied: [{ type: 'range', slot: 'all', val: '0-9' }],
                check: (n) => true,
                choices: [
                    { type: 'set', slot: 'a', val: '{1,2}', factor: 0.2, check: (n) => {
                        const a = Math.floor(n/100);
                        return a === 1 || a === 2;
                    }},
                    { type: 'equal', slot: 'c', val: '5', factor: 0.1, check: (n) => n % 10 === 5 },
                    { type: 'set', slot: 'b', val: '{0,1}', factor: 0.2, check: (n) => Math.floor((n%100)/10) < 2 }
                ],
                correctIndex: [0, 2]
            },
            {
                start: 1000,
                target: 125,
                slots: ['?', '?', '?'],
                applied: [{ type: 'range', slot: 'all', val: '0-9' }],
                check: (n) => true,
                choices: [
                    { type: 'all-set', slot: 'all', val: '{1,3,5,7,9}', factor: 0.125, check: (n) => {
                        const a = Math.floor(n/100), b = Math.floor((n%100)/10), c = n%10;
                        return a%2!==0 && b%2!==0 && c%2!==0;
                    }},
                    { type: 'equal', slot: 'a', val: '0', factor: 0.1, check: (n) => Math.floor(n/100) === 0 },
                    { type: 'not-equal', slot: 'all', val: 'A=B=C', factor: 0.01, check: (n) => {
                        const a = Math.floor(n/100), b = Math.floor((n%100)/10), c = n%10;
                        return a === b && b === c;
                    }}
                ],
                correctIndex: [0]
            }
        ];

        let currentLevelIndex = 0;
        let isAnimating = false;

        // Initialize Visualization Grid
        const visualizer = document.getElementById('pattern-visualizer');
        const dots = [];
        for (let i = 0; i < 1000; i++) {
            const dot = document.createElement('div');
            dot.className = 'dot';
            visualizer.appendChild(dot);
            dots.push(dot);
        }

        function renderConditionUI(cond) {
            let slotIcon = '';
            if (cond.slot === 'all') {
                slotIcon = `<span class="condition-icon bg-white text-[10px]">ALL</span>`;
            } else {
                slotIcon = `<span class="condition-icon ${SLOT_COLORS[cond.slot]}">?</span>`;
            }

            let symbol = '=';
            if (cond.type === 'not-equal') symbol = '≠';
            if (cond.type === 'set' || cond.type === 'all-set') symbol = '∈';
            if (cond.type === 'range') symbol = ':';

            return `<div class="flex items-center gap-2">${slotIcon} <span class="opacity-40 mx-1">${symbol}</span> <span class="font-bold">${cond.val}</span></div>`;
        }

        function updateGrid(checkFn, isTemp = false) {
            let activeCount = 0;
            dots.forEach((dot, i) => {
                const isMatch = checkFn(i);
                if (isMatch) {
                    dot.classList.add('active');
                    dot.classList.remove('target-lost');
                    activeCount++;
                } else {
                    dot.classList.remove('active');
                    if (isTemp) dot.classList.add('target-lost');
                }
            });
            document.getElementById('match-percent').innerText = `${activeCount} / 1000 ACTIVE`;
        }

        function initLevel() {
            const level = levels[currentLevelIndex];
            document.getElementById('level-display').innerText = `STG: ${currentLevelIndex + 1}/${levels.length}`;
            document.getElementById('target-count').innerText = level.target;
            document.getElementById('current-count').innerText = level.start;
            
            document.getElementById('slot-a-val').innerText = level.slots[0];
            document.getElementById('slot-b-val').innerText = level.slots[1];
            document.getElementById('slot-c-val').innerText = level.slots[2];

            const appliedContainer = document.getElementById('applied-chips-list');
            appliedContainer.innerHTML = level.applied.map(cond => `<div class="applied-badge">${renderConditionUI(cond)}</div>`).join('');

            updateGrid(level.check);

            const choicesContainer = document.getElementById('choices-container');
            choicesContainer.innerHTML = '';
            level.choices.forEach((choice, index) => {
                const btn = document.createElement('button');
                btn.className = 'chip-btn w-full p-4 rounded-lg text-left text-sm';
                btn.innerHTML = renderConditionUI(choice);
                btn.onclick = () => handleChoice(index);
                choicesContainer.appendChild(btn);
            });

            document.getElementById('message-box').innerHTML = `<span class="opacity-50 tracking-widest">>> SELECT PATCH TO REACH TARGET [${level.target}]</span>`;
            document.getElementById('message-box').classList.remove('text-red-400', 'text-green-400');
        }

        async function handleChoice(index) {
            if (isAnimating) return;
            isAnimating = true;

            const level = levels[currentLevelIndex];
            const choice = level.choices[index];
            const isCorrect = level.correctIndex.includes(index);

            const msgBox = document.getElementById('message-box');
            msgBox.innerHTML = `<span class="animate-pulse">RUNNING SIMULATION...</span>`;

            if (choice.check) updateGrid(choice.check, true);

            const resultVal = isCorrect ? level.target : Math.round(level.start * choice.factor);
            await animateCount('current-count', level.start, resultVal);

            if (isCorrect) {
                msgBox.innerHTML = `<span class="text-green-400 font-bold">✔ SUCCESS</span><br><span class="opacity-50">TARGET MATCHED. NEXT SECTOR UNLOCKED.</span>`;
                document.getElementById('game-container').classList.add('success-node');
                
                setTimeout(() => {
                    document.getElementById('game-container').classList.remove('success-node');
                    currentLevelIndex++;
                    if (currentLevelIndex < levels.length) {
                        initLevel();
                        isAnimating = false;
                    } else {
                        document.getElementById('result-modal').classList.remove('hidden');
                    }
                }, 1800);
            } else {
                msgBox.innerHTML = `<span class="text-red-500 font-bold">✘ ERROR</span><br><span class="opacity-50">MISMATCH DETECTED. RETRY PATCHING.</span>`;
                setTimeout(() => {
                    updateGrid(level.check);
                    animateCount('current-count', resultVal, level.start);
                    msgBox.innerHTML = `<span class="opacity-30">>> RE-SELECT PATCH...</span>`;
                    isAnimating = false;
                }, 2000);
            }
        }

        function animateCount(id, start, end) {
            return new Promise(resolve => {
                const obj = document.getElementById(id);
                let current = start;
                const duration = 800;
                const startTime = performance.now();

                function update(now) {
                    const elapsed = now - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const ease = 1 - Math.pow(1 - progress, 4);
                    current = Math.floor(start + (end - start) * ease);
                    obj.innerText = current;
                    if (progress < 1) requestAnimationFrame(update);
                    else { obj.innerText = end; resolve(); }
                }
                requestAnimationFrame(update);
            });
        }

        function resetGame() {
            currentLevelIndex = 0;
            document.getElementById('result-modal').classList.add('hidden');
            initLevel();
        }

        // Matrix Background
        const canvas = document.getElementById('matrix-bg');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const drops = Array(Math.floor(canvas.width / 14)).fill(1);
        function drawMatrix() {
            ctx.fillStyle = "rgba(5, 5, 8, 0.15)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#041";
            ctx.font = "14px monospace";
            drops.forEach((y, i) => {
                const text = Math.floor(Math.random() * 10);
                ctx.fillText(text, i * 14, y * 14);
                if (y * 14 > canvas.height && Math.random() > 0.975) drops[i] = 0;
                drops[i]++;
            });
        }

        window.onload = () => {
            initLevel();
            setInterval(drawMatrix, 50);
        };
        window.onresize = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };
    </script>
</body>
</html>