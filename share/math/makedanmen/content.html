<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D断面当てゲーム - 直感操作版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f4f8;
            font-family: 'sans-serif';
        }

        canvas {
            display: block;
        }

        .top-left-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .top-right-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 10;
            text-align: center;
            border: 3px solid #3b82f6;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn-go {
            background-color: #f97316;
            color: white;
            font-weight: bold;
            padding: 12px;
            width: 100%;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 0 #c2410c;
        }

        .btn-go:hover {
            background-color: #ea580c;
        }

        .btn-go:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #c2410c;
        }

        .btn-reset {
            background-color: #64748b;
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }

        #message-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translate(-50%, 0);
            z-index: 100;
            display: none;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            padding: 20px 60px;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        #msg-title {
            color: #1e293b;
        }

        #msg-body {
            color: #475569;
        }

        select {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #cbd5e1;
            background-color: white;
            font-size: 14px;
            min-width: 150px;
        }
    </style>
</head>

<body>
    <div id="message-overlay">
        <h2 id="msg-title" class="text-2xl font-bold mb-2"></h2>
        <p id="msg-body" class="mb-4 font-medium"></p>
        <button id="msg-btn"
            class="bg-blue-600 text-white px-8 py-2 rounded-full font-bold hover:bg-blue-700 transition"
            onclick="closeOverlay()">OK</button>
    </div>

    <div class="top-left-ui">
        <select id="level-select" onchange="loadLevel(parseInt(this.value))"></select>
        <button class="btn-reset" onclick="resetAll()">角度リセット</button>
    </div>

    <div class="top-right-ui">
        <h3 class="text-xs font-bold text-blue-600">もくひょう</h3>
        <canvas id="target-canvas" width="180" height="180"
            style="background: #fff; border: 1px solid #e2e8f0;"></canvas>
        <button class="btn-go" id="go-button" onclick="handleGo()">GO!(せつだん)</button>
    </div>

    <script>
        // --- グローバル変数 ---
        let scene, camera, renderer, controls, raycaster;
        let compositeGroup, upperGroup, lowerGroup, poleArrow, spinHandle;
        let uiYZ, uiXZ, arrowGroupYZ, arrowGroupXZ;
        let slicePlaneHelper, scanningLine;
        let isSliced = false;

        let rotX = 0, rotY = 0, rotZ = 0;
        let currentQuat = new THREE.Quaternion();

        const ROTATION_SMOOTHNESS = 0.25;
        const SLICE_DISTANCE = 15.0;
        let scannerY = 6;
        let sliceProgress = 0;

        let isInteracting = false;
        let activeUI = null;
        let dragStart = new THREE.Vector2();

        // --- 形状生成ヘルパー ---
        function makeCuboid(xMin, xMax, yMin, yMax, zMin, zMax) {
            return [
                [xMin, yMin, zMin], [xMax, yMin, zMin], [xMax, yMax, zMin], [xMin, yMax, zMin],
                [xMin, yMin, zMax], [xMax, yMin, zMax], [xMax, yMax, zMax], [xMin, yMax, zMax]
            ];
        }
        const boxFaces = [[0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4], [1, 2, 6, 5], [2, 3, 7, 6], [3, 0, 4, 7]];

        function makeSphere(radius, offset = [0, 0, 0], segments = 12) {
            const vertices = []; const faces = [];
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI;
                const sinT = Math.sin(theta); const cosT = Math.cos(theta);
                for (let j = 0; j < segments; j++) {
                    const phi = (j / segments) * Math.PI * 2;
                    vertices.push([offset[0] + radius * sinT * Math.cos(phi), offset[1] + radius * cosT, offset[2] + radius * sinT * Math.sin(phi)]);
                }
            }
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * segments + j; const b = (i + 1) * segments + j;
                    const c = (i + 1) * segments + (j + 1) % segments; const d = i * segments + (j + 1) % segments;
                    faces.push([a, b, c, d]);
                }
            }
            return { vertices, faces };
        }

        function makePyramid(size, height, offset = [0, 0, 0]) {
            const h = height; const s = size / 2;
            const v = [[offset[0], offset[1] + h, offset[2]], [offset[0] - s, offset[1], offset[2] - s], [offset[0] + s, offset[1], offset[2] - s], [offset[0] + s, offset[1], offset[2] + s], [offset[0] - s, offset[1], offset[2] + s]];
            return { vertices: v, faces: [[1, 2, 3, 4], [0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1]] };
        }

        function makeRegularPrism(sides, radius, height) {
            const v = []; const f = [];
            for (let i = 0; i < sides; i++) { const a = (i / sides) * Math.PI * 2; v.push([Math.cos(a) * radius, -height / 2, Math.sin(a) * radius]); }
            for (let i = 0; i < sides; i++) { const a = (i / sides) * Math.PI * 2; v.push([Math.cos(a) * radius, height / 2, Math.sin(a) * radius]); }
            f.push([...Array(sides).keys()]); f.push([...Array(sides).keys()].map(i => i + sides).reverse());
            for (let i = 0; i < sides; i++) { f.push([i, (i + 1) % sides, (i + 1) % sides + sides, i + sides]); }
            return { vertices: v, faces: f };
        }

        // --- 立体プリセット ---
        const presets = {
            cube: [{ color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-1.2, 1.2, -1.2, 1.2, -1.2, 1.2), faces: boxFaces }],
            triPrism: [{ color: 0x3b82f6, sectionColor: 0x1e3a8a, ...makeRegularPrism(3, 1.5, 3) }],
            pentaPrism: [{ color: 0x3b82f6, sectionColor: 0x1e3a8a, ...makeRegularPrism(5, 1.8, 3) }],
            tBlue: [
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-2.0, 2.0, 0.2, 1.2, -0.6, 0.6), faces: boxFaces },
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-0.6, 0.6, -1.8, 0.2, -0.6, 0.6), faces: boxFaces }
            ],
            tCombo: [
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-2.0, 2.0, 0.2, 1.2, -0.6, 0.6), faces: boxFaces },
                { color: 0xef4444, sectionColor: 0x991b1b, vertices: makeCuboid(-0.6, 0.6, -1.8, 0.2, -0.6, 0.6), faces: boxFaces }
            ],
            lCombo: [
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-0.6, 0.6, -1.5, 1.5, -0.6, 0.6), faces: boxFaces },
                { color: 0xef4444, sectionColor: 0x991b1b, vertices: makeCuboid(0.6, 1.8, -1.5, -0.3, -0.6, 0.6), faces: boxFaces }
            ],
            button: [
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-1.8, 1.8, -1.0, 0.0, -1.8, 1.8), faces: boxFaces },
                {
                    color: 0xef4444, sectionColor: 0x991b1b, ...(() => {
                        const s = makeSphere(1.2, [0, 0, 0], 16);
                        s.vertices = s.vertices.map(v => [v[0], Math.max(0.0, v[1]), v[2]]);
                        return s;
                    })()
                }
            ],
            sShape: [
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-1.5, 0.5, 0.0, 1.0, -0.5, 0.5), faces: boxFaces },
                { color: 0xef4444, sectionColor: 0x991b1b, vertices: makeCuboid(-0.5, 1.5, -1.0, 0.0, -0.5, 0.5), faces: boxFaces }
            ],
            crossDeco: [
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-2.5, 2.5, -0.3, 0.3, -0.4, 0.4), faces: boxFaces },
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-0.4, 0.4, -0.3, 0.3, -2.5, 2.5), faces: boxFaces },
                { color: 0xef4444, sectionColor: 0x991b1b, ...makeSphere(0.5, [2.5, 0.8, 0]) },
                { color: 0x10b981, sectionColor: 0x064e3b, ...makePyramid(1.0, 1.2, [-2.5, 0.3, 0]) },
                { color: 0xf59e0b, sectionColor: 0x78350f, vertices: makeCuboid(-0.4, 0.4, 0.3, 1.1, 2.1, 2.9), faces: boxFaces },
                { color: 0xef4444, sectionColor: 0x991b1b, ...makeSphere(0.5, [0, 0.8, -2.5]) }
            ],
            octaDeco: (() => {
                const s = 2.25; // 1.5倍
                const parts = [{ color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: [[s, 0, 0], [-s, 0, 0], [0, s, 0], [0, -s, 0], [0, 0, s], [0, 0, -s]], faces: [[0, 2, 4], [0, 4, 3], [0, 3, 5], [0, 5, 2], [1, 2, 5], [1, 5, 3], [1, 3, 4], [1, 4, 2]] }];
                parts.push({ color: 0xef4444, sectionColor: 0x991b1b, ...makeSphere(0.5, [s, 0, 0]) });
                parts.push({ color: 0x10b981, sectionColor: 0x064e3b, ...makePyramid(0.7, 0.9, [-s, 0, 0]) });
                parts.push({ color: 0xf59e0b, sectionColor: 0x78350f, vertices: makeCuboid(-0.4, 0.4, s, s + 0.8, -0.4, 0.4), faces: boxFaces });
                parts.push({ color: 0xef4444, sectionColor: 0x991b1b, ...makeSphere(0.5, [0, -s, 0]) });
                parts.push({ color: 0x10b981, sectionColor: 0x064e3b, ...makePyramid(0.7, 0.9, [0, 0, s]) });
                parts.push({ color: 0xf59e0b, sectionColor: 0x78350f, vertices: makeCuboid(-0.4, 0.4, -0.4, 0.4, -s - 0.8, -s), faces: boxFaces });
                return parts;
            })(),
            diagTri: [{ color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: [[-1.5, -1.5, -1.5], [1.5, -1.5, -1.5], [-1.5, 1.5, -1.5], [-1.5, -1.5, 1.5], [1.5, -1.5, 1.5], [-1.5, 1.5, 1.5]], faces: [[0, 1, 2], [3, 4, 5], [0, 1, 4, 3], [1, 2, 5, 4], [2, 0, 3, 5]] }],
            tube: [
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-1.5, -1.2, -1.5, 1.5, -1.5, 1.5), faces: boxFaces },
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(1.2, 1.5, -1.5, 1.5, -1.5, 1.5), faces: boxFaces },
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-1.2, 1.2, -1.5, -1.2, -1.5, 1.5), faces: boxFaces },
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-1.2, 1.2, 1.2, 1.5, -1.5, 1.5), faces: boxFaces }
            ],
            dented: [
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-1.5, 1.5, -1.5, -0.5, -1.5, 1.5), faces: boxFaces },
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-1.5, -0.5, -0.5, 1.5, -1.5, 1.5), faces: boxFaces },
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(0.5, 1.5, -0.5, 1.5, -1.5, 1.5), faces: boxFaces },
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-0.5, 0.5, -0.5, 1.5, -1.5, -0.5), faces: boxFaces },
                { color: 0x3b82f6, sectionColor: 0x1e3a8a, vertices: makeCuboid(-0.5, 0.5, -0.5, 1.5, 0.5, 1.5), faces: boxFaces }
            ]
        };

        // --- レベル定義と制約設定 ---
        const levels = [



        
            {
                id: 'cube', title: "Level 1: 立方体",
                solutions: [[45, 45, 0]],
                initial: [45, 0, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: true, step: 45 }, localY: { enabled: true, step: 45 } }
            },
            {
                id: 'triPrism', title: "Level 2: 三角柱",
                solutions: [[90, 0, 0], [90, 120, 0]],
                initial: [0, 45, 0],
                config: { worldX: { enabled: true, step: 90 }, worldY: { enabled: true, step: 60 }, localY: { enabled: false, step: 45 } }
            },
            {
                id: 'pentaPrism', title: "Level 3: 五角柱",
                solutions: [[45, 0, 0]],
                initial: [0, 0, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: false, step: 72 }, localY: { enabled: true, step: 72 } }
            },
            {
                id: 'tBlue', title: "Level 4: T字 (青)",
                solutions: [[0, 45, 0]],
                initial: [90, 0, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: true, step: 90 }, localY: { enabled: true, step: 45 } }
            },
            {
                id: 'tCombo', title: "Level 5: T字 (赤青)",
                solutions: [[90, 0, 0]],
                initial: [0, 0, 0],
                config: { worldX: { enabled: true, step: 90 }, worldY: { enabled: true, step: 90 }, localY: { enabled: false, step: 45 } }
            },
            {
                id: 'lCombo', title: "Level 6: L字 (赤青)",
                solutions: [[45, 135, 45]],
                initial: [0, 45, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: true, step: 45 }, localY: { enabled: true, step: 45 } }
            },
            {
                id: 'button', title: "Level 7: 早押しボタン",
                solutions: [[45, 0, 0]],
                initial: [0, 0, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: true, step: 45 }, localY: { enabled: false, step: 45 } }
            },
            {
                id: 'sShape', title: "Level 8: S字テトロミノ",
                solutions: [[0, 90, 0]],
                initial: [90, 0, 0],
                config: { worldX: { enabled: true, step: 90 }, worldY: { enabled: true, step: 90 }, localY: { enabled: true, step: 90 } }
            },
            {
                id: 'crossDeco', title: "Level 9: 十字飾り",
                solutions: [[0, 0, 0]],
                initial: [45, 45, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: true, step: 45 }, localY: { enabled: true, step: 45 } }
            },
            {
                id: 'octaDeco', title: "Level 10: デコ正八面体",
                solutions: [[45, 45, 45]],
                initial: [0, 0, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: true, step: 45 }, localY: { enabled: true, step: 45 } }
            },
            {
                id: 'diagTri', title: "Level 11: 斜め三角柱",
                solutions: [[45, 0, 0]],
                initial: [0, 0, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: true, step: 90 }, localY: { enabled: false, step: 45 } }
            },
            {
                id: 'tube', title: "Level 12: 四角い筒",
                solutions: [[45, 45, 0]],
                initial: [0, 0, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: true, step: 45 }, localY: { enabled: true, step: 45 } }
            },
            {
                id: 'dented', title: "Level 13: 凹みのある直方体",
                solutions: [[45, 0, 0]],
                initial: [0, 0, 0],
                config: { worldX: { enabled: true, step: 45 }, worldY: { enabled: true, step: 45 }, localY: { enabled: false, step: 45 } }
            }
        ];

        // --- 管理関数 (グローバル定義) ---

        function stitchSegments(segments) {
            if (segments.length === 0) return [];
            const loops = []; const used = new Array(segments.length).fill(false);
            while (used.includes(false)) {
                let currIdx = used.indexOf(false);
                let loop = [segments[currIdx][0], segments[currIdx][1]];
                used[currIdx] = true;
                let foundNext = true;
                while (foundNext) {
                    foundNext = false;
                    let lastPt = loop[loop.length - 1];
                    for (let i = 0; i < segments.length; i++) {
                        if (used[i]) continue;
                        let p1 = segments[i][0], p2 = segments[i][1];
                        if (lastPt.distanceTo(p1) < 0.01) { loop.push(p2); used[i] = true; foundNext = true; break; }
                        if (lastPt.distanceTo(p2) < 0.01) { loop.push(p1); used[i] = true; foundNext = true; break; }
                    }
                }
                if (loop.length >= 3) loops.push(loop);
            }
            return loops;
        }

        function createCompositeObject(partsArr) {
            if (compositeGroup) scene.remove(compositeGroup);
            if (upperGroup) { scene.remove(upperGroup); upperGroup = null; }
            if (lowerGroup) { scene.remove(lowerGroup); lowerGroup = null; }

            compositeGroup = new THREE.Group();
            partsArr.forEach(def => {
                const g = new THREE.BufferGeometry(); const ids = [];
                def.faces.forEach(f => { for (let i = 1; i < f.length - 1; i++) ids.push(f[0], f[i], f[i + 1]); });
                g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(def.vertices.flat()), 3));
                g.setIndex(ids); g.computeVertexNormals();
                const m = new THREE.Mesh(g, new THREE.MeshPhongMaterial({ color: def.color, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }));
                m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0x334155, opacity: 0.3, transparent: true })));
                compositeGroup.add(m);
            });
            poleArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 2.2, 0xffffaa, 0.4, 0.25);
            compositeGroup.add(poleArrow);
            spinHandle = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), new THREE.MeshBasicMaterial({ color: 0xabf2a6 }));
            spinHandle.position.set(0, 2.5, 0); spinHandle.name = "spinHandle"; compositeGroup.add(spinHandle);
            compositeGroup.quaternion.copy(currentQuat); scene.add(compositeGroup);

            isSliced = false;
            sliceProgress = 0;

            const config = levels[currentLevelIdx].config;
            uiYZ.visible = config.worldX.enabled; arrowGroupYZ.visible = config.worldX.enabled;
            uiXZ.visible = config.worldY.enabled; arrowGroupXZ.visible = config.worldY.enabled;
            poleArrow.visible = config.localY.enabled; spinHandle.visible = config.localY.enabled;
        }

        function loadLevel(idx) {
            currentLevelIdx = idx; const level = levels[idx];
            document.getElementById('level-select').value = idx;
            document.getElementById('go-button').innerText = "GO!(せつだん)";

            // ★ 初期角度の設定
            const initAngles = level.initial || [0, 0, 0];
            currentQuat.copy(composeRotation(initAngles[0], initAngles[1], initAngles[2]));
            decomposeRotation(); // 四元数から各変数を同期

            createCompositeObject(presets[level.id]);
            const sol = level.solutions[0];
            drawTargetSection(calculateSectionPointsForQuaternion(presets[level.id], composeRotation(sol[0], sol[1], sol[2])));
            document.getElementById('message-overlay').style.display = 'none';
        }

        function resetToLevelStart() { createCompositeObject(presets[levels[currentLevelIdx].id]); document.getElementById('go-button').innerText = "GO!(せつだん)"; }

        function resetAll() {
            // 現在のレベルの初期角度に戻す
            const initAngles = levels[currentLevelIdx].initial || [0, 0, 0];
            currentQuat.copy(composeRotation(initAngles[0], initAngles[1], initAngles[2]));
            decomposeRotation();
            resetToLevelStart();
        }

        function handleGo() {
            if (!isSliced) { performSlice(); isSliced = true; document.getElementById('go-button').innerText = "もどる"; checkClear(); }
            else { resetToLevelStart(); }
        }

        function performSlice() {
            scene.remove(compositeGroup); upperGroup = new THREE.Group(); lowerGroup = new THREE.Group();
            const pTop = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0), pBot = new THREE.Plane(new THREE.Vector3(0, 0, -1), 0);
            presets[levels[currentLevelIdx].id].forEach(def => {
                const mat = new THREE.Matrix4().makeRotationFromQuaternion(currentQuat);
                const worldV = def.vertices.map(v => new THREE.Vector3(...v).applyMatrix4(mat));
                const segments = [];
                def.faces.forEach(f => {
                    const hits = [];
                    for (let i = 0; i < f.length; i++) {
                        const p1 = worldV[f[i]], p2 = worldV[f[(i + 1) % f.length]];
                        if (p1.z * p2.z <= 0 && p1.z !== p2.z) hits.push(new THREE.Vector3().lerpVectors(p1, p2, -p1.z / (p2.z - p1.z)));
                    }
                    if (hits.length >= 2) segments.push([hits[0].clone(), hits[1].clone()]);
                });
                const loops = stitchSegments(segments);
                const createMesh = (planes) => {
                    const g = new THREE.BufferGeometry(); const ids = [];
                    def.faces.forEach(f => { for (let i = 1; i < f.length - 1; i++) ids.push(f[0], f[i], f[i + 1]); });
                    g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(def.vertices.flat()), 3));
                    g.setIndex(ids); g.computeVertexNormals();
                    const m = new THREE.Mesh(g, new THREE.MeshPhongMaterial({ color: def.color, side: THREE.DoubleSide, clippingPlanes: planes, transparent: true, opacity: 0.9 }));
                    m.quaternion.copy(currentQuat); return m;
                };
                upperGroup.add(createMesh([pTop])); lowerGroup.add(createMesh([pBot]));
                loops.forEach(loop => {
                    const shape = new THREE.Shape(); shape.moveTo(loop[0].x, loop[0].y);
                    for (let i = 1; i < loop.length; i++) shape.lineTo(loop[i].x, loop[i].y);
                    const cap = new THREE.Mesh(new THREE.ShapeGeometry(shape), new THREE.MeshPhongMaterial({ color: def.sectionColor, side: THREE.DoubleSide }));
                    cap.renderOrder = 2; lowerGroup.add(cap);
                });
            });
            scene.add(upperGroup); scene.add(lowerGroup);
        }

        function calculateSectionPointsForQuaternion(parts, q) {
            const res = [];
            parts.forEach(def => {
                const mat = new THREE.Matrix4().makeRotationFromQuaternion(q);
                const worldV = def.vertices.map(v => new THREE.Vector3(...v).applyMatrix4(mat));
                const segments = [];
                def.faces.forEach(f => {
                    const hit = [];
                    for (let i = 0; i < f.length; i++) {
                        const p1 = worldV[f[i]], p2 = worldV[f[(i + 1) % f.length]];
                        if (p1.z * p2.z <= 0 && p1.z !== p2.z) hit.push(new THREE.Vector3().lerpVectors(p1, p2, -p1.z / (p2.z - p1.z)));
                    }
                    if (hit.length >= 2) segments.push([hit[0].clone(), hit[1].clone()]);
                });
                const loops = stitchSegments(segments);
                if (loops.length > 0) res.push({ sectionColor: def.sectionColor, path: loops });
            });
            return res;
        }

        function drawTargetSection(data) {
            const canvas = document.getElementById('target-canvas'); const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 180, 180); const scale = 30, cx = 90, cy = 90;
            ctx.strokeStyle = "#e2e8f0"; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(180, cy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, 180); ctx.stroke();
            data.forEach(d => d.path.forEach(loop => {
                ctx.beginPath(); const color = d.sectionColor;
                ctx.fillStyle = `rgb(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255})`;
                loop.forEach((p, i) => { const x = cx + p.x * scale, y = cy - p.y * scale; if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
                ctx.closePath(); ctx.fill();
            }));
        }

        function composeRotation(lat, lon, spin) {
            const qLon = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), THREE.MathUtils.degToRad(lon));
            const qLat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(lat));
            const qSpin = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), THREE.MathUtils.degToRad(spin));
            let q = new THREE.Quaternion().copy(qSpin); q.premultiply(qLat); q.premultiply(qLon); return q;
        }

        function decomposeRotation() {
            const pole = new THREE.Vector3(0, 1, 0).applyQuaternion(currentQuat);
            let latRad = Math.acos(THREE.MathUtils.clamp(pole.y, -1, 1));
            let lonRad = (Math.abs(pole.y) < 0.9999) ? Math.atan2(pole.x, pole.z) : 0;
            const qL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), lonRad);
            const qT = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), latRad);
            const qBase = new THREE.Quaternion().multiplyQuaternions(qL, qT);
            const qS = qBase.clone().invert().multiply(currentQuat);
            let spinRad = 2 * Math.atan2(qS.y, qS.w);
            const config = levels[currentLevelIdx].config;
            const rStep = (v, s) => (Math.round(THREE.MathUtils.radToDeg(v) / s) * s % 360 + 360) % 360;
            rotX = rStep(latRad, config.worldX.step); rotY = rStep(lonRad, config.worldY.step); rotZ = rStep(spinRad, config.localY.step);
            currentQuat.copy(composeRotation(rotX, rotY, rotZ));
            console.log(`State: Level ${currentLevelIdx + 1}, rotX=${rotX}, rotY=${rotY}, rotZ=${rotZ}`);
        }

        function handleRotate(type, dir) {
            const config = levels[currentLevelIdx].config; if (isSliced) resetToLevelStart();
            const dq = new THREE.Quaternion();
            if (type === 'worldX' && config.worldX.enabled) { dq.setFromAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(dir * config.worldX.step)); currentQuat.premultiply(dq); }
            else if (type === 'worldY' && config.worldY.enabled) { dq.setFromAxisAngle(new THREE.Vector3(0, 1, 0), THREE.MathUtils.degToRad(dir * config.worldY.step)); currentQuat.premultiply(dq); }
            else if (type === 'localY' && config.localY.enabled) { dq.setFromAxisAngle(new THREE.Vector3(0, 1, 0), THREE.MathUtils.degToRad(dir * config.localY.step)); currentQuat.multiply(dq); }
            decomposeRotation();
        }

        function createArcArrow(startAngle, lengthAngle, radius, thickness, rotationAxis) {
            const group = new THREE.Group();
            class ArcCurve extends THREE.Curve { constructor(r, s, l) { super(); this.r = r; this.s = s; this.l = l; } getPoint(t) { const a = this.s + t * this.l; return new THREE.Vector3(Math.cos(a) * this.r, Math.sin(a) * this.r, 0); } }
            const curve = new ArcCurve(radius, startAngle, lengthAngle);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false, transparent: true });
            group.add(new THREE.Mesh(new THREE.TubeGeometry(curve, 40, thickness, 8, false), mat));
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.6, 12), mat);
            const h1 = head.clone(); h1.position.copy(curve.getPoint(0)); h1.rotation.z = startAngle + Math.PI; group.add(h1);
            const h2 = head.clone(); h2.position.copy(curve.getPoint(1)); h2.rotation.z = startAngle + lengthAngle; group.add(h2);
            if (rotationAxis === 'y') group.rotation.y = Math.PI / 2; if (rotationAxis === 'x') group.rotation.x = -Math.PI / 2;
            return group;
        }

        function createUIHandles() {
            const radius = 6.0; const width = 4.0;
            const sYZ = Math.PI * 4 / 20, lYZ = Math.PI * 4 / 20;
            uiYZ = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, width, 32, 1, true, sYZ, lYZ), new THREE.MeshBasicMaterial({ color: 0xff9900, side: THREE.DoubleSide }));
            uiYZ.rotation.z = Math.PI / 2; uiYZ.name = "uiYZ"; uiYZ.renderOrder = 2000; scene.add(uiYZ);
            arrowGroupYZ = createArcArrow(sYZ + Math.PI * 9 / 20, lYZ - Math.PI / 10, radius, 0.05, 'y');
            arrowGroupYZ.children.forEach(c => c.renderOrder = 3000); scene.add(arrowGroupYZ);
            const iR = 4.5, oR = 7.0, mR = (iR + oR) / 2;
            const sXZ = Math.PI / 2 - Math.PI / 5, lXZ = Math.PI * 2 / 5;
            uiXZ = new THREE.Mesh(new THREE.RingGeometry(iR, oR, 32, 1, sXZ, lXZ), new THREE.MeshBasicMaterial({ color: 0x10b981, side: THREE.DoubleSide }));
            uiXZ.rotation.x = Math.PI / 2; uiXZ.name = "uiXZ"; uiXZ.renderOrder = 2000; uiXZ.position.y = -1.5; scene.add(uiXZ);
            arrowGroupXZ = createArcArrow(sXZ - Math.PI + Math.PI / 20, lXZ - Math.PI / 10, mR, 0.05, 'x');
            arrowGroupXZ.children.forEach(c => c.renderOrder = 3000); arrowGroupXZ.position.y = -1.5; scene.add(arrowGroupXZ);
        }

        function onPointerDown(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects([uiYZ, uiXZ, spinHandle].filter(o => o));
            if (hits.length > 0) {
                const hit = hits[0].object;
                if (hit.name === "spinHandle") handleRotate('localY', 1);
                else { activeUI = hit.name; dragStart.set(e.clientX, e.clientY); isInteracting = true; controls.enabled = false; }
            }
        }
        function onPointerMove(e) { }
        function onPointerUp(e) {
            if (!isInteracting) return; isInteracting = false; controls.enabled = true;
            const dx = e.clientX - dragStart.x, dy = e.clientY - dragStart.y; const threshold = 20;
            if (activeUI === "uiYZ") { if (Math.abs(dy) > threshold) handleRotate('worldX', dy > 0 ? 1 : -1); }
            else if (activeUI === "uiXZ") { if (Math.abs(dx) > threshold) handleRotate('worldY', dx > 0 ? 1 : -1); }
            activeUI = null;
        }

        window.onload = function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0xf8fafc);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 16);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.localClippingEnabled = true; document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
            raycaster = new THREE.Raycaster();
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dl = new THREE.DirectionalLight(0xffffff, 0.5); dl.position.set(5, 10, 7); scene.add(dl);
            const select = document.getElementById('level-select');
            levels.forEach((lvl, i) => { const opt = document.createElement('option'); opt.value = i; opt.innerText = lvl.title; select.appendChild(opt); });
            createUIHandles();
            slicePlaneHelper = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), new THREE.MeshBasicMaterial({ color: 0x111100, transparent: true, opacity: 0.3, side: THREE.DoubleSide, depthWrite: false }));
            slicePlaneHelper.renderOrder = 1; scene.add(slicePlaneHelper);
            scanningLine = new THREE.Mesh(new THREE.PlaneGeometry(12, 0.3), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, side: THREE.DoubleSide, depthWrite: false }));
            scanningLine.renderOrder = 1000; scene.add(scanningLine);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            loadLevel(0); animate();
            window.addEventListener('resize', onWindowResize);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (compositeGroup && !isSliced) {
                compositeGroup.quaternion.slerp(currentQuat, ROTATION_SMOOTHNESS);
                scannerY -= 0.15; if (scannerY < -6) scannerY = 6;
                scanningLine.position.y = scannerY; scanningLine.visible = true; slicePlaneHelper.visible = true;
            } else { scanningLine.visible = false; slicePlaneHelper.visible = !isSliced; }
            sliceProgress += ((isSliced ? 1 : 0) - sliceProgress) * 0.1;
            if (upperGroup && lowerGroup) {
                upperGroup.position.z = sliceProgress * SLICE_DISTANCE;
                upperGroup.children.forEach(c => { if (c.material) c.material.opacity = 1 - sliceProgress; });
                lowerGroup.rotation.set(0, 0, 0);
            }
            controls.update(); renderer.render(scene, camera);
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function checkClear() {
            for (let sol of levels[currentLevelIdx].solutions) { if (rotX === sol[0] && rotY === sol[1] && rotZ === sol[2]) { setTimeout(() => { showModal("正解！", "回転角度がピッタリ一致しました。"); }, 1000); return; } }
        }
        function showModal(title, body) { document.getElementById('msg-title').innerText = title; document.getElementById('msg-body').innerText = body; document.getElementById('message-overlay').style.display = 'block'; }
        function closeOverlay() { document.getElementById('message-overlay').style.display = 'none'; }
    </script>
</body>

</html>