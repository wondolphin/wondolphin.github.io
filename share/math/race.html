<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ€é€Ÿã‚´ãƒ¼ãƒ«ã¯èª°ã ï¼Ÿ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: none; /* ã‚¹ãƒãƒ›ã§ã®ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã«ã‚ˆã‚‹ã‚ºãƒ¼ãƒ ã‚’ç„¡åŠ¹åŒ– */
        }
        .text-shadow {
            text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
        }
        .modal-bg {
            background-color: rgba(0, 0, 0, 0.5);
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-emerald-950 text-white flex flex-col h-screen p-4">

    <div class="w-full max-w-5xl mx-auto flex flex-col h-full">
        <div class="flex-shrink-0">
            <h1 id="title" class="text-3xl md:text-4xl font-bold text-center mb-2 text-shadow text-yellow-300">æœ€é€Ÿã‚´ãƒ¼ãƒ«ã¯èª°ã ï¼Ÿ</h1>
            <p id="instruction" class="text-center text-lg mb-2 text-gray-300">å…ˆã«ã‚´ãƒ¼ãƒ«ã™ã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸ã‚“ã§ã­ï¼</p>
        </div>
        
        <div class="flex-grow relative bg-emerald-900 rounded-lg shadow-2xl overflow-hidden border-4 border-yellow-400">
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <!-- çµæœè¡¨ç¤ºãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="resultModal" class="hidden fixed inset-0 modal-bg flex items-center justify-center">
        <div class="bg-gray-800 border-4 border-yellow-400 rounded-lg p-8 text-center shadow-2xl transform transition-all scale-95">
            <h2 id="resultTitle" class="text-5xl font-bold mb-4"></h2>
            <p id="resultMessage" class="text-xl mb-6"></p>
            <button id="resetButton" class="bg-yellow-500 text-gray-900 font-bold py-3 px-8 rounded-lg hover:bg-yellow-400 transition-colors text-2xl shadow-lg">ã‚‚ã†ä¸€åº¦éŠã¶</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const title = document.getElementById('title');
        const instruction = document.getElementById('instruction');
        const resultModal = document.getElementById('resultModal');
        const resultTitle = document.getElementById('resultTitle');
        const resultMessage = document.getElementById('resultMessage');
        const resetButton = document.getElementById('resetButton');

        // --- ã‚²ãƒ¼ãƒ è¨­å®š ---
        const GRID_ROWS = 5;
        const GRID_COLS = 8;
        const BASE_SPEED = 4; // åŸºæº–ã¨ãªã‚‹é€Ÿã•

        const playerA = {
            name: "A",
            color: "#3b82f6", // blue-500
            routeData: ["02","4","12","6","13","6","14","6","15","2","16","4","17","4","27","4","37","4","47"],
            pos: { x: 0, y: 0 },
            progress: 0, // ãƒ¬ãƒ¼ã‚¹ä¸­ã®é€²æ—
            path: [], // ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã®çµŒè·¯
            totalTime: 0 // ã‚´ãƒ¼ãƒ«ã¾ã§ã®ç·æ™‚é–“
        };

        const playerB = {
            name: "B",
            color: "#ef4444", // red-500
            routeData: ["01","4","11","4","21","6","22","4","23","4","24","4","25","4","26","4","36","4","46"],
            pos: { x: 0, y: 0 },
            progress: 0,
            path: [],
            totalTime: 0
        };

        const players = [playerA, playerB];
        let cellSize, offsetX, offsetY;
        let particles = [];
        let gameState = 'waiting'; // 'waiting', 'racing', 'finished'
        let selectedPlayer = null;
        let winner = null;
        let animationFrameId;

        // --- åˆæœŸåŒ–å‡¦ç† ---
        function init() {
            resizeCanvas();
            parseRoutes();
            calculateGoalTimes();
            createParticles();
            
            gameState = 'waiting';
            selectedPlayer = null;
            winner = null;
            players.forEach(p => {
                p.progress = 0;
                p.pos = { ...p.path[0].start };
            });

            instruction.textContent = 'å…ˆã«ã‚´ãƒ¼ãƒ«ã™ã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸ã‚“ã§ã­ï¼';
            resultModal.classList.add('hidden');
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        // --- Canvasã®ãƒªã‚µã‚¤ã‚º ---
        function resizeCanvas() {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            
            // æ­£æ–¹å½¢ã®ã‚°ãƒªãƒƒãƒ‰ã«ã™ã‚‹ãŸã‚ã®è¨ˆç®—
            const cellWidthBasedOnCanvas = canvas.width / GRID_COLS;
            const cellHeightBasedOnCanvas = canvas.height / GRID_ROWS;
            cellSize = Math.min(cellWidthBasedOnCanvas, cellHeightBasedOnCanvas);

            const gridActualWidth = cellSize * GRID_COLS;
            const gridActualHeight = cellSize * GRID_ROWS;
            offsetX = (canvas.width - gridActualWidth) / 2;
            offsetY = (canvas.height - gridActualHeight) / 2;
        }

        // --- ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ã‚’ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã«å¤‰æ› ---
        function gridToPixel(row, col) {
            return {
                x: offsetX + col * cellSize + cellSize / 2,
                y: offsetY + row * cellSize + cellSize / 2
            };
        }
        
        // --- ãƒ«ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’è§£æã—ã¦ãƒ”ã‚¯ã‚»ãƒ«çµŒè·¯ã¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’è¨­å®š ---
        function parseRoutes() {
            players.forEach(player => {
                player.path = [];
                let cumulativeDistance = 0; // ç´¯ç©è·é›¢ã‚’è¿½è·¡
                for (let i = 0; i < player.routeData.length - 1; i += 2) {
                    const startCoords = player.routeData[i];
                    const speed = parseInt(player.routeData[i+1]);
                    const endCoords = player.routeData[i+2];

                    const startPos = gridToPixel(parseInt(startCoords[0]), parseInt(startCoords[1]));
                    const endPos = gridToPixel(parseInt(endCoords[0]), parseInt(endCoords[1]));
                    
                    const dx = endPos.x - startPos.x;
                    const dy = endPos.y - startPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    cumulativeDistance += distance; // ç´¯ç©è·é›¢ã‚’æ›´æ–°

                    player.path.push({
                        start: startPos,
                        end: endPos,
                        speed: speed,
                        distance: distance,
                        cumulativeDistance: cumulativeDistance, // ç´¯ç©è·é›¢ã‚’ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«ä¿å­˜
                        dx: dx,
                        dy: dy
                    });
                }
            });
        }
        
        // --- ã‚´ãƒ¼ãƒ«ã¾ã§ã®æ™‚é–“ã‚’äº‹å‰ã«è¨ˆç®— ---
        function calculateGoalTimes() {
            players.forEach(player => {
                player.totalTime = 0;
                player.path.forEach(segment => {
                    const relativeSpeed = segment.speed / BASE_SPEED;
                    if (relativeSpeed > 0) {
                        player.totalTime += segment.distance / relativeSpeed;
                    }
                });
            });
        }

        // --- é€Ÿã•ã‚’è¡¨ç¾ã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ ---
        function createParticles() {
            particles = [];
            players.forEach(player => {
                player.path.forEach(segment => {
                    // é€Ÿã•ã«å¿œã˜ã¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ•°ã‚’å¤‰ãˆã‚‹
                    const numParticles = Math.round(segment.speed * 2);
                    for (let i = 0; i < numParticles; i++) {
                        particles.push({
                            segment: segment,
                            progress: i / numParticles, // ç­‰é–“éš”ã§é…ç½®
                            speed: (segment.speed / BASE_SPEED) * 0.01 // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç§»å‹•é€Ÿåº¦
                        });
                    }
                });
            });
        }

        // --- æç”»å‡¦ç† ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawRoutes();
            drawParticles();
            drawStartAndGoal();
            drawPlayers();
        }

        function drawGrid() {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.lineWidth = 1;

            // æ°´å¹³ç·šã‚’0.5ãƒã‚¹ãšã‚‰ã—ã¦æç”»
            for (let i = 0; i < GRID_ROWS; i++) {
                ctx.beginPath();
                const y = offsetY + (i + 0.5) * cellSize;
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + GRID_COLS * cellSize, y);
                ctx.stroke();
            }

            // å‚ç›´ç·šã‚’0.5ãƒã‚¹ãšã‚‰ã—ã¦æç”»
            for (let i = 0; i < GRID_COLS; i++) {
                ctx.beginPath();
                const x = offsetX + (i + 0.5) * cellSize;
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + GRID_ROWS * cellSize);
                ctx.stroke();
            }
        }
        
        function getSpeedColor(speed) {
            switch (speed) {
                case 6: return "#ef4444"; // red-500
                case 4: return "#f97316"; // orange-500
                case 2: return "#22c55e"; // green-500
                default: return "#6b7280"; // gray-500
            }
        }

        function drawRoutes() {
            ctx.lineWidth = 8; // é“ã‚’å¤ªãã™ã‚‹
            ctx.lineCap = "round";

            players.forEach(player => {
                player.path.forEach(segment => {
                    ctx.strokeStyle = getSpeedColor(segment.speed);
                    ctx.beginPath();
                    ctx.moveTo(segment.start.x, segment.start.y);
                    ctx.lineTo(segment.end.x, segment.end.y);
                    ctx.stroke();
                });
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                const x = p.segment.start.x + p.segment.dx * p.progress;
                const y = p.segment.start.y + p.segment.dy * p.progress;
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawStartAndGoal() {
            players.forEach(player => {
                // Start
                const startPos = player.path[0].start;
                ctx.fillStyle = player.color;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(startPos.x, startPos.y, cellSize * 0.15, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Goal
                const goalPos = player.path[player.path.length - 1].end;
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = `${cellSize * 0.4}px sans-serif`;
                ctx.fillText("ğŸ", goalPos.x, goalPos.y);
            });
        }

        function drawPlayers() {
             players.forEach(player => {
                ctx.fillStyle = player.color;
                ctx.strokeStyle = "white";
                ctx.lineWidth = 3;

                ctx.beginPath();
                ctx.arc(player.pos.x, player.pos.y, cellSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = "white";
                ctx.font = `bold ${cellSize * 0.25}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(player.name, player.pos.x, player.pos.y);
            });
        }
        
        // --- ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— ---
        function update() {
            // Particle animation
            particles.forEach(p => {
                p.progress += p.speed;
                if (p.progress >= 1) {
                    p.progress = 0;
                }
            });

            if (gameState !== 'racing') return;

            let raceFinishedThisFrame = false;

            for (const player of players) {
                const totalDistance = player.path[player.path.length - 1].cumulativeDistance;

                // æ—¢ã«ã‚´ãƒ¼ãƒ«ã—ã¦ã„ã‚‹ã‹ã€ã¾ãŸã¯ä»–ã®èª°ã‹ãŒã‚´ãƒ¼ãƒ«æ¸ˆã¿ã®å ´åˆã¯å‹•ãã‚’æ­¢ã‚ã‚‹
                if (player.progress >= totalDistance || winner) {
                    continue;
                }

                // ç¾åœ¨ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ç´¯ç©è·é›¢ã§æ­£ã—ãè¦‹ã¤ã‘ã‚‹
                const currentSegment = player.path.find(segment => player.progress < segment.cumulativeDistance);
                
                if (currentSegment) {
                    // é€²è¡Œåº¦ã‚’æ›´æ–°
                    const relativeSpeed = currentSegment.speed / BASE_SPEED;
                    player.progress += relativeSpeed * 2; // é€Ÿåº¦ã®èª¿æ•´å€¤

                    // ã‚´ãƒ¼ãƒ«ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
                    if (player.progress >= totalDistance) {
                        player.progress = totalDistance; // ã‚´ãƒ¼ãƒ«åœ°ç‚¹ã«ã‚¹ãƒŠãƒƒãƒ—
                        player.pos = player.path[player.path.length - 1].end;
                        
                        // ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§æœ€åˆã®ã‚´ãƒ¼ãƒ«è€…ã§ã‚ã‚Œã°ã€å‹è€…ã¨ã™ã‚‹
                        if (!winner) {
                            winner = player;
                            raceFinishedThisFrame = true;
                        }
                    } else {
                        // æ–°ã—ã„ä½ç½®ã‚’è¨ˆç®—
                        const currentSegmentIndex = player.path.indexOf(currentSegment);
                        const distanceBeforeSegment = currentSegmentIndex > 0 ? player.path[currentSegmentIndex - 1].cumulativeDistance : 0;
                        const progressInSegment = player.progress - distanceBeforeSegment;
                        const ratio = progressInSegment / currentSegment.distance;
                        
                        player.pos.x = currentSegment.start.x + currentSegment.dx * ratio;
                        player.pos.y = currentSegment.start.y + currentSegment.dy * ratio;
                    }
                }
            }

            if (raceFinishedThisFrame) {
                endGame();
            }
        }

        function gameLoop() {
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ ---
        function startGame() {
            if (gameState !== 'waiting' || !selectedPlayer) return;
            gameState = 'racing';
            instruction.textContent = "ãƒ¬ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ¼ãƒˆï¼";
        }

        function endGame() {
            gameState = 'finished';

            // ã‚¨ãƒ©ãƒ¼ã‚’é˜²ããŸã‚ã«ã€winnerãŒnullã§ãªã„ã“ã¨ã‚’ç¢ºèª
            if (!winner) {
                console.error("Winner could not be determined.");
                instruction.textContent = 'ãƒ¬ãƒ¼ã‚¹çµ‚äº†ï¼å‹è€…ã‚’æ±ºå®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚';
                return;
            }

            instruction.textContent = `å‹è€…ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${winner.name}ï¼`;
            
            if (selectedPlayer === winner) {
                resultTitle.textContent = "ğŸ‰ æ­£è§£ï¼ ğŸ‰";
                resultTitle.className = "text-5xl font-bold mb-4 text-yellow-400";
                resultMessage.textContent = `ãŠã‚ã§ã¨ã†ï¼ã‚ãªãŸã®äºˆæƒ³é€šã‚Šã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${winner.name}ãŒå‹ã¡ã¾ã—ãŸï¼`;
            } else {
                resultTitle.textContent = "ğŸ˜­ æ®‹å¿µ... ğŸ˜­";
                resultTitle.className = "text-5xl font-bold mb-4 text-blue-400";
                resultMessage.textContent = `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${winner.name}ãŒå…ˆã«ã‚´ãƒ¼ãƒ«ã—ã¾ã—ãŸã€‚`;
            }
            resultModal.classList.remove('hidden');
            setTimeout(() => {
                resultModal.querySelector('div').classList.remove('scale-95');
            }, 10);
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        function handleCanvasClick(event) {
            if (gameState !== 'waiting') return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            
            players.forEach(player => {
                const startPos = player.path[0].start;
                const distance = Math.sqrt(Math.pow(x - startPos.x, 2) + Math.pow(y - startPos.y, 2));
                if (distance < cellSize * 0.3) {
                    selectedPlayer = player;
                    instruction.textContent = `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${player.name}ã‚’é¸æŠï¼ãƒ¬ãƒ¼ã‚¹ã‚’é–‹å§‹ã—ã¾ã™...`;
                    // é¸æŠã•ã‚ŒãŸã‚­ãƒ£ãƒ©ã‚’å°‘ã—å¤§ããã™ã‚‹ãªã©ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                    setTimeout(startGame, 1000);
                }
            });
        }

        window.addEventListener('resize', init);
        canvas.addEventListener('click', handleCanvasClick);
        resetButton.addEventListener('click', init);

        // --- åˆæœŸåŒ–å®Ÿè¡Œ ---
        init();
    </script>
</body>
</html>

