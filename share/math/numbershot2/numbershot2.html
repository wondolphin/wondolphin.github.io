<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Shot - JSON Compatible</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            flex-direction: column;
            color: white;
            user-select: none;
        }
        #game-container {
            position: relative;
            touch-action: none;
        }
        canvas {
            background-color: #0f3460;
            border: 4px solid #16213e;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(0,0,0,0.6);
            display: block;
            cursor: crosshair;
        }
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 10px 25px;
            border-radius: 50px;
            backdrop-filter: blur(5px);
        }
        #resetButton, #stageSelector {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 25px;
            border: none;
            background-color: #e94560;
            color: white;
            transition: all 0.2s;
        }
        #stageSelector {
            background-color: #fff;
            color: #1a1a2e;
        }
        #resetButton:hover { background-color: #ff5e78; transform: translateY(-2px); }
        #resetButton:active { transform: translateY(0); }

        .ui-info {
            position: absolute;
            top: -45px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="ui-info">
            <span id="stageLabel">STAGE 1</span>
            <span id="bounceLabel">BOUNCES: 3</span>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="controls">
        <select id="stageSelector">
            <!-- JSで動的に生成 -->
        </select>
        <button id="resetButton">リセット</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const resetButton = document.getElementById('resetButton');
        const stageSelector = document.getElementById('stageSelector');

        // --- Configuration ---
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 500;
        const BALL_RADIUS = 20;
        const BALL_SPEED = 15;
        const MAX_BOUNCES = 3;
        const SHOOTER_COLOR = "#feca57"; 
        const BALL_COLORS = [
            '#ff2e63', '#08d9d6', '#eaeaea', '#ff9f43', '#1dd1a1', 
            '#54a0ff', '#5f27cd', '#f368e0', '#ee5253', '#0abde3', '#10ac84'
        ];

        // --- JSON Stage Data (Editor Output Format) ---
        const STAGES = [
            
           
            {
                "name": "ステージ 2: 障害物",
                "targets": [
                    { "x": 400, "y": 80, "n": 42 },
                    { "x": 100, "y": 100, "n": 5 },
                    { "x": 700, "y": 100, "n": 7 },
                    { "x": 160, "y": 260, "n": 15 },
                    { "x": 640, "y": 260, "n": 14 }
                ],
                "shooters": [
                    { "x": 300, "y": 440, "n": 3 },
                    { "x": 500, "y": 440, "n": 2 },
                    { "x": 400, "y": 350, "n": 7 },
                    { "x": 400, "y": 440, "n": 5 }

                ],
                "walls": [
                    { "x": 300, "y": 180, "w": 200, "h": 15 },
                     { "x": 750, "y": 300, "w": 40, "h": 400 },
                      { "x": 0, "y": 300, "w": 40, "h": 400 }
                ]
            },
            {
    "name": "カスタムステージ",
    "targets": [
        {
            "x": 426,
            "y": 251,
            "n": 20
        }
    ],
    "shooters": [
        {
            "x": 211,
            "y": 104,
            "n": 2
        },
        {
            "x": 430,
            "y": 445,
            "n": 3
        },
        {
            "x": 660,
            "y": 118,
            "n": 4
        }
    ],
    "walls": [
        {
            "x": 312,
            "y": 176,
            "w": 27,
            "h": 184
        },
        {
            "x": 518,
            "y": 182,
            "w": 26,
            "h": 179
        }
    ]
},
            {
                "name": "ステージ 3: 長距離反射",
                "targets": [
                    { "x": 400, "y": 280, "n": 100 },
                    { "x": 400, "y": 80, "n": 20 }
                ],
                "shooters": [
                    { "x": 80, "y": 80, "n": 2 },
                    { "x": 80, "y": 420, "n": 5 },
                    { "x": 720, "y": 420, "n": 10 }
                ],
                "walls": [
                    { "x": 200, "y": 100, "w": 20, "h": 300 },
                    { "x": 580, "y": 100, "w": 20, "h": 300 }
                ]
            },
            {
    "name": "カスタムステージ",
    "targets": [
        {
            "x": 412,
            "y": 103,
            "n": 8
        }
    ],
    "shooters": [
        {
            "x": 711,
            "y": 379,
            "n": 2
        },
        {
            "x": 422,
            "y": 377,
            "n": 2
        },
        {
            "x": 118,
            "y": 378,
            "n": 2
        }
    ],
    "walls": [
        {
            "x": 223,
            "y": 286,
            "w": 391,
            "h": 24
        },
        {
            "x": 14,
            "y": 150,
            "w": 200,
            "h": 20
        },
        {
            "x": 593,
            "y": 189,
            "w": 19,
            "h": 96
        }
    ]
},
{
    "name": "カスタムステージ",
    "targets": [
        {
            "x": 267,
            "y": 100,
            "n": 6
        },
        {
            "x": 530,
            "y": 97,
            "n": 12
        }
    ],
    "shooters": [
        {
            "x": 296,
            "y": 289,
            "n": 2
        },
        {
            "x": 734,
            "y": 450,
            "n": 3
        },
        {
            "x": 527,
            "y": 290,
            "n": 2
        },
        {
            "x": 46,
            "y": 235,
            "n": 6
        }
    ],
    "walls": [
        {
            "x": 396,
            "y": 3,
            "w": 35,
            "h": 348
        },
        {
            "x": 197,
            "y": 217,
            "w": 200,
            "h": 20
        },
        {
            "x": 432,
            "y": 222,
            "w": 200,
            "h": 20
        }
    ]
}
        ];

        let activeBall = null;
        let availableBalls = [];
        let targetBalls = [];
        let walls = [];
        let isDragging = false;
        let selectedBall = null;
        let trajectory = [];
        let highlightedTargets = new Set();
        let highlightedShooters = new Set();
        let currentStageIndex = 0;
        let isGameClear = false;
        let isGameOver = false;

        function getBallColor(number, isShooter) {
            if (isShooter) return SHOOTER_COLOR;
            if (number === 1) return "#ffffff";
            return BALL_COLORS[(number - 2 + BALL_COLORS.length) % BALL_COLORS.length];
        }

        class Ball {
            constructor(x, y, radius, number, isShooter = false) {
                this.x = x; this.y = y; this.radius = radius;
                this.number = number;
                this.isShooter = isShooter;
                this.color = getBallColor(number, isShooter);
                this.vx = 0; this.vy = 0;
                this.isMoving = false;
                this.passedBalls = new Set();
                this.bounceCount = 0;
                this.opacity = 1.0;
                this.isDissolving = false;
            }

            draw() {
                if (this.opacity <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                const isHighlighted = (this.isShooter && highlightedShooters.has(this)) || (!this.isShooter && highlightedTargets.has(this));
                if (isHighlighted) {
                    ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                    ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 5;
                } else {
                    ctx.strokeStyle = this.isShooter ? "#ffffff" : "#16213e";
                    ctx.lineWidth = this.isShooter ? 4 : 2;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * (this.isDissolving ? this.opacity : 1), 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill(); ctx.stroke();

                if (this.isShooter && !this.isMoving) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 6, 0, Math.PI * 2);
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.4)"; ctx.lineWidth = 2; ctx.stroke();
                }

                if (!this.isDissolving) {
                    ctx.fillStyle = "#1a1a2e";
                    ctx.font = `bold ${this.radius * 0.9}px sans-serif`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(this.number, this.x, this.y);
                }
                ctx.restore();
            }

            update() {
                if (this.isDissolving) { this.opacity -= 0.05; return; }
                if (!this.isMoving) return;
                
                this.x += this.vx; this.y += this.vy;

                let bounced = false;
                if (this.x - this.radius <= 0 || this.x + this.radius >= GAME_WIDTH) {
                    this.vx *= -1; this.x = (this.x - this.radius <= 0) ? this.radius : GAME_WIDTH - this.radius;
                    bounced = true;
                }
                if (this.y - this.radius <= 0 || this.y + this.radius >= GAME_HEIGHT) {
                    this.vy *= -1; this.y = (this.y - this.radius <= 0) ? this.radius : GAME_HEIGHT - this.radius;
                    bounced = true;
                }

                for (const w of walls) {
                    if (this.checkWallCollision(w)) { bounced = true; break; }
                }

                if (bounced) {
                    this.bounceCount++;
                    if (this.bounceCount >= MAX_BOUNCES) { this.stopAndRemove(); return; }
                }

                for (const ab of availableBalls) {
                    if (this === ab) continue;
                    if (Math.hypot(this.x - ab.x, this.y - ab.y) < (this.radius + ab.radius) * 0.9) {
                        ab.number += this.number;
                        this.stopAndRemove(); return;
                    }
                }

                for (const tb of targetBalls) {
                    if (tb.isDissolving || this.passedBalls.has(tb)) continue;
                    if (Math.hypot(this.x - tb.x, this.y - tb.y) < (this.radius + tb.radius) * 0.9) {
                        if (tb.number > 1 && tb.number % this.number === 0) {
                            tb.number /= this.number;
                            tb.color = getBallColor(tb.number, false);
                            if (tb.number === 1) tb.isDissolving = true;
                            checkGameStatus();
                        }
                        this.passedBalls.add(tb);
                    }
                }
            }

            checkWallCollision(w) {
                const cX = Math.max(w.x, Math.min(this.x, w.x + w.w));
                const cY = Math.max(w.y, Math.min(this.y, w.y + w.h));
                const dX = this.x - cX; const dY = this.y - cY;
                if ((dX * dX + dY * dY) < (this.radius * this.radius)) {
                    if (Math.abs(dX) > Math.abs(dY)) { this.vx *= -1; this.x = cX + (dX > 0 ? this.radius : -this.radius); }
                    else { this.vy *= -1; this.y = cY + (dY > 0 ? this.radius : -this.radius); }
                    return true;
                }
                return false;
            }

            stopAndRemove() {
                this.isMoving = false; activeBall = null; checkGameStatus();
            }
        }

        function setup() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = GAME_WIDTH * dpr; canvas.height = GAME_HEIGHT * dpr;
            canvas.style.width = `${GAME_WIDTH}px`; canvas.style.height = `${GAME_HEIGHT}px`;
            ctx.scale(dpr, dpr);

            // セレクターの生成
            STAGES.forEach((s, i) => {
                const opt = document.createElement('option');
                opt.value = i; opt.innerText = s.name;
                stageSelector.appendChild(opt);
            });

            resetGame();
            addEventListeners();
            gameLoop();
        }

        function resetGame() {
            isGameClear = false; isGameOver = false;
            activeBall = null; selectedBall = null;
            resetButton.classList.remove('highlight-button');
            
            const stageJson = STAGES[currentStageIndex];
            document.getElementById('stageLabel').innerText = stageJson.name;
            
            // JSONデータから直接マッピング
            walls = stageJson.walls.map(w => ({...w}));
            targetBalls = stageJson.targets.map(t => new Ball(t.x, t.y, BALL_RADIUS, t.n, false));
            availableBalls = stageJson.shooters.map(s => new Ball(s.x, s.y, BALL_RADIUS, s.n, true));
        }

        function checkGameStatus() {
            const remaining = targetBalls.filter(b => !b.isDissolving && b.number > 1);
            if (remaining.length === 0) {
                isGameClear = true; activeBall = null;
            } else if (availableBalls.length === 0 && !activeBall) {
                isGameOver = true; resetButton.classList.add('highlight-button');
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = "#0f3460"; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            ctx.fillStyle = "#16213e";
            walls.forEach(w => {
                ctx.fillRect(w.x, w.y, w.w, w.h);
                ctx.strokeStyle = "#e94560"; ctx.lineWidth = 1; ctx.strokeRect(w.x, w.y, w.w, w.h);
            });
            
            availableBalls.forEach(b => b.draw(b === selectedBall));
            if (activeBall) { activeBall.update(); if (activeBall) activeBall.draw(); }

            targetBalls = targetBalls.filter(b => b.opacity > 0);
            targetBalls.forEach(b => { b.update(); b.draw(); });

            if (isDragging && selectedBall) drawTrajectory();
            if (isGameClear) drawEndScreen("MISSION CLEAR");
            if (isGameOver) drawEndScreen("MISSION FAILED");

            requestAnimationFrame(gameLoop);
        }

        function drawEndScreen(msg) {
            ctx.fillStyle = 'rgba(26, 26, 46, 0.85)'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = (msg === "MISSION CLEAR") ? "#2ecc71" : "#e94560";
            ctx.font = 'bold 60px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText(msg, GAME_WIDTH / 2, GAME_HEIGHT / 2);
            ctx.fillStyle = 'white'; ctx.font = '20px sans-serif';
            ctx.fillText("リセットボタンで再挑戦", GAME_WIDTH / 2, GAME_HEIGHT / 2 + 60);
        }
        
        function addEventListeners() {
            resetButton.addEventListener('click', resetGame);
            stageSelector.addEventListener('change', (e) => {
                currentStageIndex = parseInt(e.target.value, 10);
                resetGame();
            });

            const startEvent = (e) => {
                e.preventDefault();
                if (activeBall || isGameClear || isGameOver) return;
                const pos = getEventPosition(e);
                for (const b of availableBalls) {
                    if (Math.hypot(pos.x - b.x, pos.y - b.y) < b.radius * 2.5) {
                        selectedBall = b; isDragging = true;
                        calculateTrajectory(pos); break;
                    }
                }
            };
            const moveEvent = (e) => { if (isDragging && selectedBall) calculateTrajectory(getEventPosition(e)); };
            const endEvent = (e) => {
                if (isDragging && selectedBall) {
                    isDragging = false;
                    if (trajectory.length > 1) {
                        const dx = trajectory[1].x - trajectory[0].x, dy = trajectory[1].y - trajectory[0].y;
                        const angle = Math.atan2(dy, dx);
                        activeBall = selectedBall;
                        availableBalls = availableBalls.filter(b => b !== selectedBall);
                        activeBall.vx = Math.cos(angle) * BALL_SPEED; activeBall.vy = Math.sin(angle) * BALL_SPEED;
                        activeBall.isMoving = true;
                    }
                    selectedBall = null; trajectory = []; highlightedTargets.clear(); highlightedShooters.clear();
                }
            };

            canvas.addEventListener('mousedown', startEvent);
            window.addEventListener('mousemove', moveEvent);
            window.addEventListener('mouseup', endEvent);
            canvas.addEventListener('touchstart', startEvent, {passive:false});
            window.addEventListener('touchmove', moveEvent, {passive:false});
            window.addEventListener('touchend', endEvent);
        }
        
        function getEventPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: cx - rect.left, y: cy - rect.top };
        }

        function calculateTrajectory(dragPos) {
            trajectory = []; highlightedTargets.clear(); highlightedShooters.clear();
            if (!selectedBall) return;
            const dx = selectedBall.x - dragPos.x, dy = selectedBall.y - dragPos.y;
            const angle = Math.atan2(dy, dx);
            let sim = { x: selectedBall.x, y: selectedBall.y, vx: Math.cos(angle) * BALL_SPEED, vy: Math.sin(angle) * BALL_SPEED };
            let simBounces = 0;
            trajectory.push({ x: sim.x, y: sim.y });

            for (let i = 0; i < 500; i++) {
                sim.x += sim.vx; sim.y += sim.vy;

                let hitShooter = false;
                for (const ab of availableBalls) {
                    if (ab === selectedBall) continue;
                    if (Math.hypot(sim.x - ab.x, sim.y - ab.y) < BALL_RADIUS * 1.8) {
                        highlightedShooters.add(ab); hitShooter = true;
                    }
                }
                if (hitShooter) { trajectory.push({ x: sim.x, y: sim.y }); break; }

                for (const tb of targetBalls) {
                    if (tb.isDissolving) continue;
                    if (Math.hypot(sim.x - tb.x, sim.y - tb.y) < BALL_RADIUS * 1.8) {
                        if (tb.number % selectedBall.number === 0) highlightedTargets.add(tb);
                    }
                }

                let hitWall = false;
                if (sim.x - BALL_RADIUS <= 0 || sim.x + BALL_RADIUS >= GAME_WIDTH) { sim.vx *= -1; hitWall = true; }
                if (sim.y - BALL_RADIUS <= 0 || sim.y + BALL_RADIUS >= GAME_HEIGHT) { sim.vy *= -1; hitWall = true; }
                for(const w of walls) {
                    const cX = Math.max(w.x, Math.min(sim.x, w.x + w.w)), cY = Math.max(w.y, Math.min(sim.y, w.y + w.h));
                    if (Math.hypot(sim.x - cX, sim.y - cY) < BALL_RADIUS) {
                        if (Math.abs(sim.x - cX) > Math.abs(sim.y - cY)) sim.vx *= -1; else sim.vy *= -1;
                        hitWall = true; break;
                    }
                }
                if (hitWall) {
                    simBounces++; trajectory.push({ x: sim.x, y: sim.y });
                    if (simBounces >= MAX_BOUNCES) break;
                }
            }
            if (trajectory[trajectory.length-1].x !== sim.x) trajectory.push({ x: sim.x, y: sim.y });
        }
        
        function drawTrajectory() {
            ctx.save(); ctx.strokeStyle = 'rgba(254, 202, 87, 0.5)'; ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]); ctx.beginPath();
            if (trajectory.length > 0) {
                ctx.moveTo(trajectory[0].x, trajectory[0].y);
                for(let i=1; i<trajectory.length; i++) ctx.lineTo(trajectory[i].x, trajectory[i].y);
            }
            ctx.stroke(); ctx.restore();
        }

        setup();
    </script>
</body>
</html>