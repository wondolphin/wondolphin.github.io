<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dブロック積み上げゲーム</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'sans-serif'; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .preview-slot { 
            width: 120px; height: 120px; 
            background: rgba(0, 0, 0, 0.4); 
            border: 2px solid #444;
            border-radius: 8px; 
            pointer-events: auto; 
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, border-color 0.2s;
            overflow: hidden;
        }
        .preview-slot:hover { border-color: #888; }
        .preview-slot:active { cursor: grabbing; transform: scale(0.95); }
        .preview-slot canvas { display: block; }
        #message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            z-index: 100;
        }
        #clear-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 100, 0.9);
            color: black;
            padding: 20px 60px;
            border-radius: 10px;
            font-size: 48px;
            font-weight: bold;
            display: none;
            z-index: 200;
            box-shadow: 0 0 30px rgba(0, 255, 100, 0.5);
        }
        .control-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="flex justify-center gap-6 mt-6">
        <div id="slot-0" class="preview-slot" onpointerdown="startDrag(0, event)"></div>
        <div id="slot-1" class="preview-slot" onpointerdown="startDrag(1, event)"></div>
        <div id="slot-2" class="preview-slot" onpointerdown="startDrag(2, event)"></div>
    </div>

    <div class="fixed top-6 right-6 flex gap-2">
        <button class="control-btn" onclick="undoLastMove()">一手戻る</button>
        <button class="control-btn" onclick="resetGame()">リセット</button>
    </div>
    
    <div id="message-box"></div>
    <div id="clear-display">CLEAR!!</div>
</div>

<script>
/**
 * 定数と設定
 */
const STAGE_SIZE = 4;
const TARGET_HEIGHT = 4; 
const FALL_SPEED = 0.2; 

const TARGET_BACK = [ 
    [0,0,0,0],
    [0,1,1,0],
    [0,0,1,0],
    [1,1,1,1]
];

const TARGET_LEFT = [ 
    [0,0,0,0],
    [0,0,1,1],
    [1,0,0,1],
    [1,1,1,1]
];

const PIECE_DEFINITIONS = [
    { name: "L字テトロミノ", shape: [[0,0,0], [0,1,0], [1,0,0]], color: 0xff5555 },
    { name: "O型テトロミノ", shape: [[0,0,0], [-1,0,0], [0,0,1], [-1,0,1]], color: 0xffff55 },
    { name: "ドミノ", shape: [[0,0,0], [0,1,0]], color: 0x55ff55 }
];

/**
 * ゲーム状態
 */
let scene, camera, renderer, raycaster;
let previewScenes = [], previewCameras = [], previewRenderers = [];

let stageOccupied = Array(STAGE_SIZE).fill().map(() => Array(STAGE_SIZE).fill(0));
let voxelData = Array(STAGE_SIZE).fill().map(() => 
    Array(STAGE_SIZE * 2).fill().map(() => 
        Array(STAGE_SIZE).fill(false)
    )
);

let draggingPiece = null;
let dragMesh = null;
let targetPlane; 
let fallingPieces = []; 
let placedPiecesGroup;
let isCleared = false;
let history = []; // 履歴スタック

let screenBackCtx, screenLeftCtx;
let screenBackTexture, screenLeftTexture;

/**
 * 初期化
 */
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(12, 14, 12);
    camera.lookAt(1.0, 2.0, 1.0); 

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    raycaster = new THREE.Raycaster();
    placedPiecesGroup = new THREE.Group();
    scene.add(placedPiecesGroup);

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 15, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // 床
    const gridHelperBottom = new THREE.GridHelper(STAGE_SIZE, STAGE_SIZE, 0x888888, 0x333333);
    gridHelperBottom.position.set(1.5, 0, 1.5);
    scene.add(gridHelperBottom);

    const floorGeo = new THREE.PlaneGeometry(STAGE_SIZE, STAGE_SIZE);
    const floorMesh = new THREE.Mesh(floorGeo, new THREE.MeshStandardMaterial({ color: 0x222222 }));
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.position.set(1.5, -0.01, 1.5);
    floorMesh.receiveShadow = true;
    scene.add(floorMesh);

    // 判定用透明平面 (y=4)
    const targetPlaneGeo = new THREE.PlaneGeometry(STAGE_SIZE * 6, STAGE_SIZE * 6);
    targetPlane = new THREE.Mesh(targetPlaneGeo, new THREE.MeshBasicMaterial({ visible: false }));
    targetPlane.rotation.x = -Math.PI / 2;
    targetPlane.position.set(1.5, TARGET_HEIGHT, 1.5);
    scene.add(targetPlane);

    // 高さ4の可視レイヤー
    const targetVisMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(STAGE_SIZE, STAGE_SIZE),
        new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.1, side: THREE.DoubleSide })
    );
    targetVisMesh.rotation.x = -Math.PI / 2;
    targetVisMesh.position.set(1.5, TARGET_HEIGHT, 1.5);
    scene.add(targetVisMesh);

    const gridHelperTop = new THREE.GridHelper(STAGE_SIZE, STAGE_SIZE, 0xffffff, 0xffffff);
    gridHelperTop.position.set(1.5, TARGET_HEIGHT, 1.5);
    gridHelperTop.material.opacity = 0.3;
    gridHelperTop.material.transparent = true;
    scene.add(gridHelperTop);

    initScreens();

    for(let i=0; i<3; i++) initPreview3D(i);

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    animate();
}

function initScreens() {
    const canvasSize = 256;
    const createScreenCanvas = () => {
        const canvas = document.createElement('canvas');
        canvas.width = canvasSize; canvas.height = canvasSize;
        const ctx = canvas.getContext('2d');
        const texture = new THREE.CanvasTexture(canvas);
        return { canvas, ctx, texture };
    };

    const back = createScreenCanvas();
    screenBackCtx = back.ctx;
    screenBackTexture = back.texture;

    const left = createScreenCanvas();
    screenLeftCtx = left.ctx;
    screenLeftTexture = left.texture;

    const screenGeo = new THREE.PlaneGeometry(STAGE_SIZE, STAGE_SIZE);
    const screenMatBase = { roughness: 0.8, transparent: true, opacity: 0.9 };

    const screenBackMesh = new THREE.Mesh(screenGeo, new THREE.MeshStandardMaterial({ ...screenMatBase, map: screenBackTexture }));
    screenBackMesh.position.set(1.5, 2, -3.5); 
    scene.add(screenBackMesh);

    const screenLeftMesh = new THREE.Mesh(screenGeo, new THREE.MeshStandardMaterial({ ...screenMatBase, map: screenLeftTexture }));
    screenLeftMesh.rotation.y = Math.PI / 2;
    screenLeftMesh.position.set(-3.5, 2, 1.5); 
    scene.add(screenLeftMesh);
}

/**
 * スクリーン表示の更新 (点滅ロジック追加)
 */
function updateScreens() {
    const isFlashOn = (Math.floor(Date.now() / 250) % 2 === 0);

    const drawScreen = (ctx, texture, targetMatrix, projectionType) => {
        const size = ctx.canvas.width;
        const step = size / 4;

        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(0, 0, size, size);

        ctx.strokeStyle = '#dddddd';
        ctx.lineWidth = 1;
        for(let i=1; i<4; i++) {
            ctx.beginPath(); ctx.moveTo(i*step, 0); ctx.lineTo(i*step, size); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, i*step); ctx.lineTo(size, i*step); ctx.stroke();
        }

        let currentMatrix = Array(4).fill().map(() => Array(4).fill(0));
        for(let y=0; y<4; y++) {
            for(let i=0; i<4; i++) {
                let hasBlock = false;
                if (projectionType === 'back') { 
                    for(let z=0; z<4; z++) if(voxelData[i][y][z]) hasBlock = true;
                    if(hasBlock) currentMatrix[3-y][i] = 1; 
                } else { 
                    for(let x=0; x<4; x++) if(voxelData[x][y][i]) hasBlock = true;
                    if(hasBlock) currentMatrix[3-y][3-i] = 1;
                }
            }
        }

        // シルエット描画
        for(let r=0; r<4; r++) {
            for(let c=0; c<4; c++) {
                if(currentMatrix[r][c]) {
                    // 目標外のシルエット判定
                    if (!targetMatrix[r][c]) {
                        ctx.fillStyle = isFlashOn ? '#ff0000' : '#222222';
                    } else {
                        ctx.fillStyle = '#222222';
                    }
                    ctx.fillRect(c*step + 4, r*step + 4, step - 8, step - 8);
                }
            }
        }

        // 目標描画 (緑の破線)
        ctx.strokeStyle = '#00aa44';
        ctx.setLineDash([6, 4]);
        ctx.lineWidth = 4;
        for(let r=0; r<4; r++) {
            for(let c=0; c<4; c++) {
                if(targetMatrix[r][c]) {
                    ctx.strokeRect(c*step + 10, r*step + 10, step - 20, step - 20);
                }
            }
        }
        ctx.setLineDash([]);
        texture.needsUpdate = true;

        return JSON.stringify(currentMatrix) === JSON.stringify(targetMatrix);
    };

    const isBackOk = drawScreen(screenBackCtx, screenBackTexture, TARGET_BACK, 'back');
    const isLeftOk = drawScreen(screenLeftCtx, screenLeftTexture, TARGET_LEFT, 'left');

    if (isBackOk && isLeftOk && !isCleared) {
        isCleared = true;
        document.getElementById('clear-display').style.display = 'block';
    }
}

function initPreview3D(index) {
    const slot = document.getElementById(`slot-${index}`);
    const width = slot.clientWidth, height = slot.clientHeight;
    const pScene = new THREE.Scene();
    pScene.background = new THREE.Color(0x222222);
    const pCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
    pCamera.position.set(3.5, 3.5, 3.5);
    pScene.add(new THREE.AmbientLight(0xffffff, 1.0));
    const pRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    pRenderer.setSize(width, height);
    slot.appendChild(pRenderer.domElement);
    previewScenes[index] = pScene;
    previewCameras[index] = pCamera;
    previewRenderers[index] = pRenderer;

    const data = PIECE_DEFINITIONS[index];
    const group = new THREE.Group();
    const material = new THREE.MeshStandardMaterial({ color: data.color });
    const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
    let sumX = 0, sumY = 0, sumZ = 0, count = data.shape.length;
    data.shape.forEach(p => { sumX += p[0]; sumY += p[1]; sumZ += p[2]; });
    data.shape.forEach(p => {
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(p[0] - sumX/count, p[1] - sumY/count, p[2] - sumZ/count);
        group.add(cube);
    });
    pScene.add(group);
    pCamera.lookAt(0,0,0);
    group.rotation.y = Math.PI / 4;
}

function startDrag(index, event) {
    if (isCleared) return;
    const data = PIECE_DEFINITIONS[index];
    draggingPiece = { ...data, slotIndex: index };
    const group = new THREE.Group();
    const material = new THREE.MeshStandardMaterial({ color: data.color, transparent: true, opacity: 0.5 });
    data.shape.forEach(p => {
        const cube = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.96, 0.96), material);
        cube.position.set(p[0], p[1] + 0.5, p[2]);
        group.add(cube);
    });
    dragMesh = group;
    scene.add(dragMesh);
    onPointerMove(event);
}

function onPointerMove(event) {
    if (!dragMesh) return;
    const mouse = new THREE.Vector2((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(targetPlane);
    if (intersects.length > 0) {
        const pt = intersects[0].point;
        dragMesh.position.set(Math.round(pt.x), TARGET_HEIGHT, Math.round(pt.z));
    }
}

function onPointerUp(event) {
    if (!dragMesh) return;
    const mouse = new THREE.Vector2((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(targetPlane);
    if (intersects.length > 0) {
        const gx = Math.round(intersects[0].point.x), gz = Math.round(intersects[0].point.z);
        if (isInsideStage(gx, gz, draggingPiece.shape)) {
            const targetY = calculateDropHeight(gx, gz, draggingPiece.shape);
            startFallingAnimation(gx, TARGET_HEIGHT, gz, targetY, draggingPiece);
        } else {
            showMessage("ステージの範囲内に置いてください");
        }
    }
    scene.remove(dragMesh);
    dragMesh = null; draggingPiece = null;
}

function isInsideStage(x, z, shape) {
    return shape.every(p => {
        const nx = x + p[0], nz = z + p[2];
        return nx >= 0 && nx < STAGE_SIZE && nz >= 0 && nz < STAGE_SIZE;
    });
}

function calculateDropHeight(x, z, shape) {
    let maxHeight = 0;
    shape.forEach(p => {
        const nx = x + p[0], nz = z + p[2];
        if (nx >= 0 && nx < STAGE_SIZE && nz >= 0 && nz < STAGE_SIZE) {
            maxHeight = Math.max(maxHeight, stageOccupied[nx][nz] - p[1]);
        }
    });
    return maxHeight;
}

function startFallingAnimation(x, startY, z, targetY, pieceData) {
    const group = new THREE.Group();
    const material = new THREE.MeshStandardMaterial({ color: pieceData.color, roughness: 0.7 });
    pieceData.shape.forEach(p => {
        const cube = new THREE.Mesh(new THREE.BoxGeometry(0.98, 0.98, 0.98), material);
        cube.position.set(p[0], p[1] + 0.5, p[2]);
        cube.castShadow = true; cube.receiveShadow = true;
        group.add(cube);
    });
    group.position.set(x, startY, z);
    placedPiecesGroup.add(group);
    fallingPieces.push({ mesh: group, x, z, currentY: startY, targetY, shape: pieceData.shape });
}

/**
 * 一手戻る処理
 */
function undoLastMove() {
    if (history.length === 0 || isCleared) return;
    
    const last = history.pop();
    
    // ボクセルデータを削除
    last.addedVoxels.forEach(v => {
        voxelData[v.x][v.y][v.z] = false;
    });
    
    // ステージの高さを以前の状態に戻す
    stageOccupied = JSON.parse(JSON.stringify(last.prevHeights));
    
    // 3Dオブジェクトを削除
    placedPiecesGroup.remove(last.mesh);
    
    showMessage("一手戻しました");
}

function resetGame() {
    stageOccupied = Array(STAGE_SIZE).fill().map(() => Array(STAGE_SIZE).fill(0));
    voxelData = Array(STAGE_SIZE).fill().map(() => Array(STAGE_SIZE * 2).fill().map(() => Array(STAGE_SIZE).fill(false)));
    while(placedPiecesGroup.children.length > 0) placedPiecesGroup.remove(placedPiecesGroup.children[0]);
    fallingPieces = [];
    history = [];
    isCleared = false;
    document.getElementById('clear-display').style.display = 'none';
    showMessage("リセットしました");
}

function showMessage(txt) {
    const box = document.getElementById('message-box');
    box.innerText = txt; box.style.display = 'block';
    setTimeout(() => { box.style.display = 'none'; }, 2000);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    
    for (let i = fallingPieces.length - 1; i >= 0; i--) {
        const p = fallingPieces[i];
        p.currentY -= FALL_SPEED;
        if (p.currentY <= p.targetY) {
            p.currentY = p.targetY;
            
            // ヒストリー用に現在の高さ情報をディープコピー
            const prevHeights = JSON.parse(JSON.stringify(stageOccupied));
            const addedVoxels = [];

            p.shape.forEach(s => {
                const fx = p.x + s[0], fy = Math.round(p.targetY + s[1]), fz = p.z + s[2];
                if (fx >= 0 && fx < STAGE_SIZE && fz >= 0 && fz < STAGE_SIZE) {
                    stageOccupied[fx][fz] = Math.max(stageOccupied[fx][fz], fy + 1);
                    if(fy >= 0 && fy < STAGE_SIZE * 2) {
                        voxelData[fx][fy][fz] = true;
                        addedVoxels.push({x: fx, y: fy, z: fz});
                    }
                }
            });
            
            // 履歴に追加
            history.push({
                mesh: p.mesh,
                addedVoxels: addedVoxels,
                prevHeights: prevHeights
            });

            fallingPieces.splice(i, 1);
        }
        p.mesh.position.y = p.currentY;
    }

    // シルエット点滅のために毎フレーム更新
    updateScreens();

    renderer.render(scene, camera);
    previewRenderers.forEach((r, i) => r.render(previewScenes[i], previewCameras[i]));
}

window.onload = init;
</script>
</body>
</html>