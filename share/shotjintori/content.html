<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Collision Game</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #222;
            color: white;
            margin: 0;
            padding: 20px;
            user-select: none; /* テキスト選択無効化 */
        }
        h1 { margin-bottom: 10px; font-size: 1.2rem;}
        
        /* ゲームコンテナ */
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: pointer;
        }

        canvas {
            background-color: #ddd; /* ニュートラルな床の色 */
            display: block;
            border-radius: 4px;
        }

        /* スコアボード */
        #scoreboard {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            /* キャンバス幅に合わせる */
            max-width: 540px; 
            margin-top: 15px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }

        .score-item {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
        }

        .color-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid #fff;
        }

        .score-val {
            font-weight: bold;
        }
        
        /* 説明文 */
        .instruction {
            margin-top: 10px;
            color: #aaa;
            font-size: 0.8rem;
        }

        /* ボタンのスタイル */
        #undoButton {
            background-color: #f58231; /* オレンジ (テーマカラーから) */
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            margin: 15px 0; /* 上下のマージンを調整 */
            box-shadow: 0 4px #9A6324; /* 茶色 (テーマカラーから) */
            transition: all 0.1s ease;
        }
        
        #undoButton:hover {
            background-color: #f79a59;
        }
        
        #undoButton:active {
            box-shadow: 0 1px #9A6324;
            transform: translateY(3px);
        }
    </style>
</head>
<body>

    <h1>スリングショット陣取り</h1>

    <div id="game-container">
        <!-- キャンバスサイズを 9x7 (540x420) に変更 -->
        <canvas id="gameCanvas" width="540" height="420"></canvas>
    </div>

    <div class="instruction">メダルをドラッグ＆ドロップして弾いてください</div>

    <!-- ★ ボタン追加 -->
    <button id="undoButton">1手戻る</button>

    <div id="scoreboard">
        <!-- JSで生成 -->
    </div>

<script>
    // --- 設定 (9x7 に変更) ---
    const COLS = 9;
    const ROWS = 7;
    const TILE_W = 60; // (540 / 9)
    const TILE_H = 60; // (420 / 7)
    const CANVAS_W = COLS * TILE_W; // 540
    const CANVAS_H = ROWS * TILE_H; // 420
    
    // 物理定数
    const FRICTION = 0.985; // 摩擦（1未満で徐々に減速）
    const WALL_BOUNCE = 0.8; // 壁の跳ね返り係数
    const MEDAL_RADIUS = 30; // ★ 1.5倍に変更 (20 -> 30)
    const SHOOT_POWER = 0.15; // 引っ張る強さの係数
    const MAX_SPEED = 25; // 最高速度制限

    // 色定義 (8色) - 区別しやすい配色に変更
    const COLORS = [
        { name: 'Red', hex: '#E6194B' },    // 赤
        { name: 'Blue', hex: '#4363d8' },   // 青
        { name: 'Green', hex: '#3cb44b' },  // 緑
        { name: 'Yellow', hex: '#ffe119' }, // 黄
        { name: 'Orange', hex: '#f58231' }, // オレンジ
        { name: 'Purple', hex: '#911eb4' }, // 紫
        { name: 'Cyan', hex: '#42d4f4' },   // 水色
        { name: 'Brown', hex: '#9A6324' }   // 茶色
    ];
    const NEUTRAL_COLOR = '#e0e0e0';

    // --- クラス定義 ---

    class Tile {
        constructor(c, r) {
            this.c = c;
            this.r = r;
            this.x = c * TILE_W;
            this.y = r * TILE_H;
            this.ownerIndex = -1; // -1はニュートラル
        }

        draw(ctx) {
            ctx.fillStyle = this.ownerIndex === -1 ? NEUTRAL_COLOR : COLORS[this.ownerIndex].hex;
            ctx.fillRect(this.x, this.y, TILE_W, TILE_H);
            
            // グリッド線
            ctx.strokeStyle = 'rgba(0,0,0,0.05)';
            ctx.strokeRect(this.x, this.y, TILE_W, TILE_H);
        }
    }

    class Medal {
        constructor(index, x, y) {
            this.index = index; // 色のインデックス
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.radius = MEDAL_RADIUS;
            this.mass = 1; // 質量はすべて同じとする
        }

        update() {
            // 位置更新
            this.x += this.vx;
            this.y += this.vy;

            // 摩擦（減速）
            this.vx *= FRICTION;
            this.vy *= FRICTION;

            // 止まりかけたら完全に止める
            if (Math.abs(this.vx) < 0.05) this.vx = 0;
            if (Math.abs(this.vy) < 0.05) this.vy = 0;

            // 壁判定
            if (this.x - this.radius < 0) {
                this.x = this.radius;
                this.vx *= -1 * WALL_BOUNCE;
            } else if (this.x + this.radius > CANVAS_W) {
                this.x = CANVAS_W - this.radius;
                this.vx *= -1 * WALL_BOUNCE;
            }

            if (this.y - this.radius < 0) {
                this.y = this.radius;
                this.vy *= -1 * WALL_BOUNCE;
            } else if (this.y + this.radius > CANVAS_H) {
                this.y = CANVAS_H - this.radius;
                this.vy *= -1 * WALL_BOUNCE;
            }
        }

        draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = COLORS[this.index].hex;
            ctx.fill();
            
            // 立体感を出すための枠線と光沢
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'white';
            ctx.stroke();
            ctx.closePath();
        }
    }

    // --- ゲームの状態管理 ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let tiles = [];
    let medals = [];
    let dragTarget = null;
    let dragStartPos = { x: 0, y: 0 };
    let currentMousePos = { x: 0, y: 0 };
    let isDragging = false;

    // ★ 履歴管理用
    let historyStack = [];
    const MAX_HISTORY = 10; // 10手前まで記憶
    let previousAllStopped = true; // メダルが停止していたかどうかの前フレームの状態

    // ★ 状態保存
    function saveState() {
        // 現在の状態をディープコピー
        const medalsState = medals.map(m => ({ x: m.x, y: m.y, vx: 0, vy: 0 })); // 速度は0で保存
        const tilesState = tiles.map(row => row.map(tile => ({ ownerIndex: tile.ownerIndex })));

        historyStack.push({ medals: medalsState, tiles: tilesState });

        // 履歴の上限管理
        if (historyStack.length > MAX_HISTORY) {
            historyStack.shift(); // 古いものから削除
        }
        console.log("状態を保存しました。履歴:", historyStack.length);
    }

    // ★ 状態復元
    function restoreState() {
        if (historyStack.length <= 1) { // 最初の状態（または履歴なし）の場合は戻れない
            console.log("これ以上戻れません");
            return;
        }

        // 現在の状態（スタックの末尾）を破棄し、1つ前の状態を読み込む
        historyStack.pop(); 
        const lastState = historyStack[historyStack.length - 1];

        if (!lastState) return;

        // 状態を復元
        medals.forEach((m, i) => {
            m.x = lastState.medals[i].x;
            m.y = lastState.medals[i].y;
            m.vx = 0; // 戻った時は必ず停止状態
            m.vy = 0;
        });

        tiles.forEach((row, r) => {
            row.forEach((tile, c) => {
                tile.ownerIndex = lastState.tiles[r][c].ownerIndex;
            });
        });

        // スコアボードも更新
        updateScoreboard();
        
        // ドラッグ状態を強制解除
        isDragging = false;
        dragTarget = null;
        previousAllStopped = true; // 状態を戻したので「停止」状態
        
        console.log("状態を1手戻しました。残り履歴:", historyStack.length);
    }


    // --- 初期化 ---
    function init() {
        // キャンバスサイズをJS側でも設定
        canvas.width = CANVAS_W;
        canvas.height = CANVAS_H;
        
        // タイル生成
        for (let r = 0; r < ROWS; r++) {
            let rowTiles = [];
            for (let c = 0; c < COLS; c++) {
                rowTiles.push(new Tile(c, r));
            }
            tiles.push(rowTiles);
        }

        // メダル生成（ランダム配置だが重ならないように簡易チェック）
        for (let i = 0; i < 8; i++) {
            let placed = false;
            while (!placed) {
                // メダルが大きくなったので、配置マージンを調整
                let tx = Math.random() * (CANVAS_W - MEDAL_RADIUS * 2) + MEDAL_RADIUS;
                let ty = Math.random() * (CANVAS_H - MEDAL_RADIUS * 2) + MEDAL_RADIUS;
                
                // 既存のメダルと近すぎないかチェック
                let tooClose = false;
                for (let m of medals) {
                    let dx = tx - m.x;
                    let dy = ty - m.y;
                    if (Math.sqrt(dx*dx + dy*dy) < MEDAL_RADIUS * 2.5) { // 判定も半径基準
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    medals.push(new Medal(i, tx, ty));
                    placed = true;
                }
            }
        }

        // スコアボード初期化
        const scoreBoard = document.getElementById('scoreboard');
        COLORS.forEach((col, idx) => {
            const div = document.createElement('div');
            div.className = 'score-item';
            div.innerHTML = `
                <div class="color-dot" style="background-color:${col.hex}"></div>
                <span id="score-${idx}" class="score-val">0</span>
            `;
            scoreBoard.appendChild(div);
        });

        // ★ 初期状態を履歴に保存
        previousAllStopped = true;
        saveState();
        
        loop();
    }

    // --- 衝突判定と解決 (メダル同士) ---
    function resolveCollisions() {
        for (let i = 0; i < medals.length; i++) {
            for (let j = i + 1; j < medals.length; j++) {
                let m1 = medals[i];
                let m2 = medals[j];

                let dx = m2.x - m1.x;
                let dy = m2.y - m1.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < m1.radius + m2.radius) {
                    // 衝突検知

                    // 1. 重なり解消（めり込み防止）
                    // 距離が0の場合のゼロ除算を防止
                    if (distance === 0) {
                        dx = 1; 
                        distance = 1;
                    }
                    
                    let overlap = (m1.radius + m2.radius - distance) / 2;
                    let nx = dx / distance; // 法線ベクトルX
                    let ny = dy / distance; // 法線ベクトルY
                    
                    m1.x -= nx * overlap;
                    m1.y -= ny * overlap;
                    m2.x += nx * overlap;
                    m2.y += ny * overlap;

                    // 2. 運動量の交換（弾性衝突）
                    // 法線方向と接線方向の速度成分に分解
                    let v1n = m1.vx * nx + m1.vy * ny;
                    let v1t = -m1.vx * ny + m1.vy * nx;
                    let v2n = m2.vx * nx + m2.vy * ny;
                    let v2t = -m2.vx * ny + m2.vy * nx;

                    // 質量が同じなので、法線方向の速度を入れ替えるだけでOK
                    let temp = v1n;
                    v1n = v2n;
                    v2n = temp;

                    // 速度ベクトルを元に戻す
                    m1.vx = v1n * nx - v1t * ny;
                    m1.vy = v1n * ny + v1t * nx;
                    m2.vx = v2n * nx - v2t * ny;
                    m2.vy = v2n * ny + v2t * nx;
                }
            }
        }
    }

    // --- 塗り判定 ---
    function updateTiles() {
        medals.forEach(m => {
            // メダルが動いている時だけ塗る（オプション）
            // if(m.vx === 0 && m.vy === 0) return; 

            // メダルの中心座標から行・列を計算
            let c = Math.floor(m.x / TILE_W);
            let r = Math.floor(m.y / TILE_H);

            // 範囲内なら色を塗る
            if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                tiles[r][c].ownerIndex = m.index;
            }
        });
    }

    // --- スコア計算 ---
    function updateScoreboard() {
        let counts = new Array(8).fill(0);
        
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                let idx = tiles[r][c].ownerIndex;
                if (idx !== -1) {
                    counts[idx]++;
                }
            }
        }

        counts.forEach((count, idx) => {
            document.getElementById(`score-${idx}`).textContent = count;
        });
    }

    // --- メインループ ---
    function loop() {
        // ★ 1. 状態保存判定 (メダルがすべて停止した瞬間に保存)
        let allStopped = medals.every(m => m.vx === 0 && m.vy === 0);
        if (allStopped && !previousAllStopped) {
            // 動いていた状態から停止した瞬間に履歴を保存
            saveState();
        }
        previousAllStopped = allStopped;


        // 2. 物理更新 (ドラッグ中は更新しない)
        if (!isDragging) {
            medals.forEach(m => m.update());
            resolveCollisions();
        }
        
        // 3. タイル判定
        updateTiles();
        
        // 4. スコア更新 (毎フレームは重いかもしれないが、今回はOK)
        updateScoreboard();

        // 5. 描画
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

        // 床描画
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                tiles[r][c].draw(ctx);
            }
        }

        // 照準線（ドラッグ中のみ）
        if (isDragging && dragTarget) {
            ctx.beginPath();
            ctx.moveTo(dragTarget.x, dragTarget.y);
            
            // ★ ガイド線ロジック変更
            let pullX = dragStartPos.x - currentMousePos.x;
            let pullY = dragStartPos.y - currentMousePos.y;
            
            let actualSpeed = Math.sqrt(pullX * pullX + pullY * pullY) * SHOOT_POWER;
            let isMaxPower = (actualSpeed >= MAX_SPEED);
            let angle = Math.atan2(pullY, pullX);

            let displayX, displayY;

            if (isMaxPower) {
                // 最大パワー時
                ctx.strokeStyle = '#FFC107'; // 黄色とオレンジの間
                ctx.lineWidth = 4; // 少し太く
                // 線の長さを固定
                let displayPull = MAX_SPEED / SHOOT_POWER;
                displayX = dragTarget.x + Math.cos(angle) * displayPull;
                displayY = dragTarget.y + Math.sin(angle) * displayPull;
            } else {
                // 通常時
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                displayX = dragTarget.x + pullX;
                displayY = dragTarget.y + pullY;
            }
            
            ctx.lineTo(displayX, displayY);
            ctx.setLineDash([5, 5]); // 点線
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.lineWidth = 3; // メダル描画のために線幅を戻す
        }

        // メダル描画
        medals.forEach(m => m.draw(ctx));

        requestAnimationFrame(loop);
    }

    // --- 入力イベント処理 ---
    
    function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function onDown(e) {
        // すべてのメダルが停止していないと操作できない
        if (!previousAllStopped) return;

        if(e.type === 'touchstart') e.preventDefault(); // スクロール防止
        const pos = getMousePos(canvas, e);
        
        // メダルをクリックしたか判定
        for (let m of medals) {
            let dx = pos.x - m.x;
            let dy = pos.y - m.y;
            // メダルが大きくなったので判定も半径基準
            if (Math.sqrt(dx*dx + dy*dy) < m.radius * 1.2) { // 判定を少し厳密に
                dragTarget = m;
                isDragging = true;
                dragStartPos = pos; // ドラッグ開始位置（ここを基準に引っ張る）
                currentMousePos = pos;
                // ドラッグ中は速度を殺す（掴むイメージ）
                m.vx = 0;
                m.vy = 0;
                break;
            }
        }
    }

    function onMove(e) {
        if (!isDragging) return;
        if(e.type === 'touchmove') e.preventDefault();
        currentMousePos = getMousePos(canvas, e);
    }

    function onUp(e) {
        if (!isDragging || !dragTarget) {
            isDragging = false;
            return;
        }
        
        // 発射処理
        // ベクトル: スタート位置 - リリース位置 (引っ張った逆方向)
        let pullX = dragStartPos.x - currentMousePos.x;
        let pullY = dragStartPos.y - currentMousePos.y;
        
        // 速度制限
        let speed = Math.sqrt(pullX * pullX + pullY * pullY) * SHOOT_POWER;
        let angle = Math.atan2(pullY, pullX);

        if (speed > MAX_SPEED) speed = MAX_SPEED;

        // わずかなドラッグでは発射しない（誤操作防止）
        if (speed > 1) {
            dragTarget.vx = Math.cos(angle) * speed;
            dragTarget.vy = Math.sin(angle) * speed;
            previousAllStopped = false; // 発射したので「動作中」フラグ
        } else {
            // 速度が小さすぎる場合はキャンセル扱い
        }

        isDragging = false;
        dragTarget = null;
    }

    // イベントリスナー登録
    canvas.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);

    canvas.addEventListener('touchstart', onDown, {passive: false});
    window.addEventListener('touchmove', onMove, {passive: false});
    window.addEventListener('touchend', onUp);

    // ★ ボタンイベントリスナー追加
    document.getElementById('undoButton').addEventListener('click', restoreState);


    // ゲーム開始
    init();

</script>
</body>
</html>