<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›³å½¢ãƒ‘ã‚ºãƒ«ã‚²ãƒ¼ãƒ </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            touch-action: none; /* ã‚¹ãƒãƒ›ã§ã®ã‚¿ãƒƒãƒæ“ä½œæ™‚ã«ç”»é¢ãŒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ */
            overflow: hidden; /* ç”»é¢å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¦æ­¢ */
        }
        canvas {
            cursor: pointer;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: block; /* canvasä¸‹ã®ä½™ç™½å‰Šé™¤ */
            margin: auto; /* ä¸­å¤®å¯„ã› */
        }
        
        /* --- ã‚¯ãƒªã‚¢æ¼”å‡º --- */
        @keyframes pop-in {
            0% { transform: scale(0.8); opacity: 0; }
            80% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes text-shine {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }

        .message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.85); /* åŠé€æ˜ã®ç™½ */
            display: none; /* åˆæœŸçŠ¶æ…‹ã¯éè¡¨ç¤º */
            flex-direction: column; /* ç¸¦ä¸¦ã³ */
            justify-content: center;
            align-items: center;
            border-radius: 0.5rem;
            pointer-events: none; /* åˆæœŸçŠ¶æ…‹ã¯æ“ä½œä¸å¯ */
            opacity: 0;
            /* transform: scale(0.9); */ /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å´ã§åˆ¶å¾¡ */
            transition: opacity 0.3s ease-in-out;
        }
        .message-overlay.show {
            display: flex; /* è¡¨ç¤º */
            opacity: 1;
            pointer-events: all; /* ã€Œã¤ãã¸ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ */
            animation: pop-in 0.4s ease-out;
        }
        #message-text {
            font-size: 3rem; /* 48px */
            font-weight: 800; /* extra-bold */
            /* è™¹è‰²ã«è¼ãã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ */
            background: linear-gradient(to right, #4F46E5, #10B981, #F59E0B, #4F46E5);
            background-size: 200% auto;
            color: transparent;
            background-clip: text;
            -webkit-background-clip: text;
            animation: text-shine 2s linear infinite;
        }
        /* --- æ¼”å‡ºã“ã“ã¾ã§ --- */
        
        /* ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ç”¨ */
        #resetButton {
            position: absolute;
            top: 0.75rem; /* 12px */
            right: 0.75rem; /* 12px */
            z-index: 10;
        }
    </style>
</head>
<!-- 
  ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´: 
  - ç”»é¢å…¨ä½“ã‚’ flex-col (ç¸¦) -> md (ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆä»¥ä¸Š) ã§ flex-row (æ¨ª) ã«å¤‰æ›´
  - ç”»é¢ã®é«˜ã•ã‚’ min-h-screen (æœ€ä½100vh) ã‹ã‚‰ h-screen (å¼·åˆ¶100vh) ã«å¤‰æ›´ã—ã€overflow-hidden ã‚’è¿½åŠ 
-->
<body class="bg-slate-100 flex flex-col md:flex-row justify-start items-start h-screen p-4 gap-4">

    <!-- å·¦å´ UIãƒ‘ãƒãƒ« (space-y-4 ã§å­è¦ç´ é–“ã«ãƒãƒ¼ã‚¸ãƒ³) -->
    <div id="ui-panel" class="w-full md:w-auto md:max-w-xs flex-shrink-0 space-y-4">
        <!-- ã‚‚ãã²ã‚‡ã† -->
        <div class="bg-white p-4 rounded-lg shadow-md">
            <h1 id="targetDisplay" class="text-xl font-bold text-slate-700">ã‚‚ãã²ã‚‡ã†ï¼š </h1> 
        </div>
        
        <!-- ã‚‚ã‚“ã ã„ã›ã‚“ãŸã -->
        <div class="bg-white p-4 rounded-lg shadow-md">
            <div class="mb-2">
                <label for="problem-select" class="text-slate-600 mr-2">ã‚‚ã‚“ã ã„ã‚’ã›ã‚“ãŸã:</label>
                <select id="problem-select" class="w-full p-2 rounded-md border border-slate-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                </select>
            </div>
        </div>
    </div>

    <!-- å³å´ ã‚²ãƒ¼ãƒ ç›¤é¢ã‚³ãƒ³ãƒ†ãƒŠ -->
    <div id="game-container" class="w-full max-w-xl mx-auto md:mx-0 flex-grow">
        <div class="relative w-full"> <!-- ã“ã®ã‚³ãƒ³ãƒ†ãƒŠãŒã‚­ãƒ£ãƒ³ãƒã‚¹ã®å¹…ã®åŸºæº– -->
            <canvas id="gameCanvas"></canvas>
            <!-- ã‚¯ãƒªã‚¢ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã€Œã¤ãã¸ã€ãƒœã‚¿ãƒ³ -->
            <div id="message" class="message-overlay">
                <span id="message-text">ã‚¯ãƒªã‚¢ï¼ ğŸŠ</span>
                <button id="nextButton" class="mt-4 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all duration-200 transform hover:scale-105">
                    ã¤ãã¸
                </button>
            </div>
            <!-- ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ -->
            <button id="resetButton" class="bg-slate-600 hover:bg-slate-700 text-white font-bold p-2 rounded-full shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
            </button>
        </div>
    </div>

    <script>
        // --- åˆæœŸè¨­å®š ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const targetDisplayEl = document.getElementById('targetDisplay'); 
        const uiPanelEl = document.getElementById('ui-panel'); // UIãƒ‘ãƒãƒ«ã®ã‚³ãƒ³ãƒ†ãƒŠ
        const gameContainerEl = document.getElementById('game-container'); // ã‚²ãƒ¼ãƒ ç›¤é¢ã®ã‚³ãƒ³ãƒ†ãƒŠ
        const resetButton = document.getElementById('resetButton');
        const messageEl = document.getElementById('message');
        const messageTextEl = document.getElementById('message-text'); // è¿½åŠ 
        const nextButton = document.getElementById('nextButton'); // è¿½åŠ 
        const problemSelectEl = document.getElementById('problem-select');

        const GRID_SIZE = 28; // ã‚°ãƒªãƒƒãƒ‰ã®ã‚µã‚¤ã‚º (30 -> 28)
        const VERTEX_RADIUS = 8; // é ‚ç‚¹ã®åŠå¾„ (æç”»ç”¨)
        const CLICK_RADIUS = 20; // é ‚ç‚¹ã®ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šåŠå¾„ (åˆ¤å®šç”¨)
        const MAX_GRID_ROWS = 15; // æœ€å¤§ç¸¦ãƒã‚¹æ•°

        // --- å•é¡Œãƒ‡ãƒ¼ã‚¿ ---
        const problems = [
        {
                title: "ãƒ¬ãƒ™ãƒ«1-1",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 3, y: 3 }, { x: 6, y: 3 }, { x: 6, y: 5 },
                    { x: 8, y: 5 }, { x: 8, y: 3 }, { x: 11, y: 3 },
                    { x: 11, y: 7 }, { x: 8, y: 7 }, { x: 8, y: 9 },
                    { x: 6, y: 9 }, { x: 6, y: 7 }, { x: 3, y: 7 }
                ]
            },
        {
                title: "ãƒ¬ãƒ™ãƒ«1-2",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 9, y: 4 }, { x: 13, y: 4 }, { x: 13, y: 6 }, { x: 13, y: 11 },
                    { x: 11, y: 11 }, { x: 11, y: 9 }, { x: 7, y: 9 },
                    { x: 7, y: 11 }, { x: 6, y: 11 }, { x: 6, y: 6 },
                    { x: 9, y: 6 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«1-3",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 8, y: 3 }, { x: 10, y: 3 }, { x: 10, y: 5 },
                    { x: 11, y: 5 }, { x: 11, y: 10 }, { x: 7, y: 10 },
                    { x: 7, y: 8 }, { x: 5, y: 8 }, { x: 5, y: 5 },
                    { x: 8, y: 5 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«1-4",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 5, y: 2 }, { x: 7, y: 2 }, { x: 7, y: 6 },
                    { x: 11, y: 6 }, { x: 11, y: 7 }, { x: 10, y: 7 },
                    { x: 10, y: 11 }, { x: 6, y: 11 }, { x: 6, y: 7 },
                    { x: 5, y: 7 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«1-5",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 3, y: 3 }, { x: 7, y: 3 }, { x: 7, y: 6 },
                    { x: 10, y: 6 }, { x: 10, y: 5 }, { x: 13, y: 5 },
                    { x: 13, y: 8 }, { x: 10, y: 8 }, { x: 3, y: 8 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«1-6",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 4, y: 5 }, { x: 7, y: 5 }, { x: 7, y: 1 },
                    { x: 11, y: 5 }, { x: 10, y: 5 },
                    { x: 10, y: 11 }, { x: 8, y: 11 }, 
                    { x: 4, y: 7 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«2-1",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 3, y: 2 }, { x: 5, y: 5 }, { x: 7, y: 3 },
                    { x: 9, y: 5 }, { x: 11, y: 2 }, { x: 11, y: 8 },
                    { x: 9, y: 11 }, { x: 7, y: 9 }, { x: 5, y: 11 },
                    { x: 3, y: 8 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«2-2",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 4, y: 2 }, { x: 10, y: 2 }, { x: 10, y: 4 },
                    { x: 12, y: 2 }, { x: 12, y: 6 }, { x: 8, y: 6 },
                    { x: 6, y: 8 }, { x: 4, y: 8 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«2-3",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 7, y: 1 }, { x: 10, y: 1 }, { x: 12, y: 4 },
                    { x: 12, y: 10 }, { x: 6, y: 10 }, { x: 6, y: 4 },
                    { x: 8, y: 7 }, { x: 11, y: 7 }, { x: 9, y: 4 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«2-4",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 6, y: 2 }, { x: 6, y: 5 }, { x: 3, y: 5 },
                    { x: 6, y: 8 }, { x: 9, y: 8 }, { x: 11, y: 8 },
                    { x: 11, y: 5 }, { x: 9, y: 5 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«2-5",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 4, y: 1 }, { x: 8, y: 1 }, { x: 8, y: 4 },
                    { x: 10, y: 5 }, { x: 10, y: 6 }, { x: 8, y: 7 },
                    { x: 4, y: 7 }, { x: 4, y: 4 }, { x: 6, y: 3 },
                    { x: 6, y: 2 }
                ]
            },
                        {
                title: "ãƒ¬ãƒ™ãƒ«2-6",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 3, y: 4 }, { x: 6, y: 6 }, { x: 11, y: 5 },
                    { x: 9, y: 10 }, { x: 4, y: 11 }, { x: 1, y: 9 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«3-1",
                targetShape: 'ä¸‰è§’å½¢',
                targetVertexCount: 3,
                vertices: [
                    { x: 4, y: 1 }, { x: 6, y: 1 }, { x: 6, y: 4 },
                    { x: 7, y: 4 }, { x: 7, y: 7 }, { x: 9, y: 7 },
                    { x: 9, y: 4 }, { x: 12, y: 4 }, { x: 9, y: 10 },
                    { x: 2, y: 4 }, { x: 4, y: 4 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«3-2",
                targetShape: 'ä¸‰è§’å½¢',
                targetVertexCount: 3,
                vertices: [
                    { x: 7, y: 2 }, { x: 8, y: 3 }, { x: 8, y: 6 },
                    { x: 9, y: 4 }, { x: 12, y: 7 }, { x: 4, y: 8 },
                    { x: 6, y: 4 }, { x: 6, y: 1 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«3-3",
                targetShape: 'ä¸‰è§’å½¢',
                targetVertexCount: 3,
                vertices: [
                    { x: 4, y: 1 }, { x: 10, y: 6 }, { x: 6, y: 6 },
                    { x: 6, y: 4 }, { x: 4, y: 6 }, { x: 4, y: 3 },
                    { x: 2, y: 3 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«3-4",
                targetShape: 'ä¸‰è§’å½¢',
                targetVertexCount: 3,
                vertices: [
                    { x: 6, y: 1 }, { x: 7, y: 3 }, { x: 8, y: 2 },
                    { x: 9, y: 10 }, { x: 7, y: 9 }, { x: 8, y: 8 },
                    { x: 7, y: 6 }, { x: 5, y: 8 }, { x: 3, y: 7 },
                    { x: 6, y: 4 }, { x: 4, y: 3 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«3-5",
                targetShape: 'ä¸‰è§’å½¢',
                targetVertexCount: 3,
                vertices: [
                    { x: 6, y: 1 }, { x: 14, y: 9 }, { x: 12, y: 8 },
                    { x: 7, y: 7 }, { x: 6, y: 9 }, { x: 7, y: 10 },
                    { x: 9, y: 11 }, { x: 12, y: 14 }, { x: 2, y: 12 },
                    { x: 1, y: 11 }, { x: 2, y: 9 }, { x: 3, y: 7 },
                    { x: 4, y: 5 }, { x: 5, y: 3 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«4-1",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 4, y: 5 }, { x: 6, y: 4 }, { x: 10, y: 7 },
                    { x: 12, y: 6 }, { x: 12, y: 11 }, { x: 8, y: 13 },
                    { x: 4, y: 10 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«4-2",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 6, y: 6 }, { x: 4, y: 10 }, { x: 2, y: 12 },
                    { x: 6, y: 14 }, { x: 8, y: 10 }, { x: 12, y: 10 },
                    { x: 8, y: 8 }, { x: 10, y: 6 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«4-3",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 4, y: 6 }, { x: 7, y: 5 }, { x: 11, y: 5 },
                    { x: 11, y: 7 }, { x: 12, y: 10 }, { x: 9, y: 11 },
                    { x: 9, y: 9 }, { x: 5, y: 9 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«4-4",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 5, y: 5 }, { x: 7, y: 3 }, { x: 11, y: 3 },
                    { x: 12, y: 6 }, { x: 10, y: 8 }, { x: 10, y: 12 },
                    { x: 9, y: 9 }, { x: 5, y: 9 }
                ]
            },

            {
                title: "ãƒ¬ãƒ™ãƒ«4-5",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 4, y: 4 }, { x: 8, y: 4 }, { x: 9, y: 7 },
                    { x: 7, y: 8 }, { x: 7, y: 13 }, { x: 3, y: 13 },
                    { x: 3, y: 8 }, { x: 5, y: 7 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«4-6",
                targetShape: 'ä¸‰è§’å½¢',
                targetVertexCount: 3,
                vertices: [
                    { x: 3, y: 9 }, { x: 6, y: 8 }, { x: 7, y: 6 },
                    { x: 5, y: 5 }, { x: 11, y: 3 }, { x: 8, y: 9 }, { x: 7, y: 11 }
                ]
            },
                        {
                title: "ãƒ¬ãƒ™ãƒ«4-7",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 6, y: 5 }, { x: 4, y: 8 }, { x: 8, y: 13 },
                    { x: 14, y: 7 }, { x: 8, y: 9 }, { x: 10, y: 6 }
                ]
            },
            {
                title: "ãƒ¬ãƒ™ãƒ«4-8",
                targetShape: 'å››è§’å½¢',
                targetVertexCount: 4,
                vertices: [
                    { x: 6, y: 6 }, { x: 8, y: 3 }, { x: 11, y: 5 },
                    { x: 9, y: 8 }, { x: 10, y: 13 }, { x: 12, y: 10 },
                    { x: 14, y: 7 }, { x: 16, y: 4 }, { x: 13, y: 2 },
                    { x: 5, y: 1 }, { x: 3, y: 4 }, { x: 4, y: 9 }
                ]
            },

            {
    title: "ãƒ¬ãƒ™ãƒ«4-9",
    targetShape: 'å››è§’å½¢',
    targetVertexCount: 4,
    vertices: [
    { x: 6, y: 2 },     { x: 8, y: 2 },     { x: 11, y: 3 }, 
    { x: 10, y: 6 },     { x: 13, y: 7 },     { x: 8, y: 12 }, 
    { x: 5, y: 11 },     { x: 6, y: 8 },     { x: 3, y: 7 }
]
}
            
        ];


        // --- ã‚¯ãƒªã‚¢ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ ---
        let problemsClearStatus = new Array(problems.length).fill(false); // â˜…ç®¡ç†ç”¨é…åˆ—

        // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        let gameState = {};

        // åˆæœŸåŒ–é–¢æ•°
        function init(problemId = 0) {
            messageEl.classList.remove('show'); // ã‚¯ãƒªã‚¢ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’éš ã™
            
            // problemId ãŒç¯„å›²å¤–ã®å ´åˆã€0ã«æˆ»ã™
            if (problemId < 0 || problemId >= problems.length) {
                problemId = 0;
            }
            
            const problem = problems[problemId];
            
            // ç›®æ¨™è¡¨ç¤ºã‚’æ›´æ–°
            let targetShapeJa = '';
            switch(problem.targetShape) {
                case 'ä¸‰è§’å½¢': targetShapeJa = 'ã•ã‚“ã‹ã'; break;
                case 'å››è§’å½¢': targetShapeJa = 'ã—ã‹ã'; break;
                default: targetShapeJa = problem.targetShape;
            }
            targetDisplayEl.textContent = `ã‚‚ãã²ã‚‡ã†ï¼š ${targetShapeJa}`;

            gameState = {
                problemId: problemId,
                phase: 'cut', // 'cut' ã¾ãŸã¯ 'combine'
                polygons: [createPolygon(problem.vertices)],
                targetShape: problem.targetShape,
                targetVertexCount: problem.targetVertexCount,
                selectedVertices: [],
                hoveredVertex: null,
                draggedPolygon: null,
                dragOffset: { x: 0, y: 0 },
            };
            
            setupProblemSelect(); // ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã‚’ï¼ˆã‚¯ãƒªã‚¢ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¾¼ã¿ã§ï¼‰å†æ§‹ç¯‰
            problemSelectEl.value = problemId; // ç¾åœ¨ã®å•é¡Œã‚’é¸æŠçŠ¶æ…‹ã«ã™ã‚‹

            resizeCanvas(); // ã‚µã‚¤ã‚ºå¤‰æ›´
            requestAnimationFrame(gameLoop); // æç”»é–‹å§‹
        }

        // ãƒãƒªã‚´ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function createPolygon(vertices) {
            return {
                vertices: vertices.map(v => ({...v})), // ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼
                color: `hsla(${Math.random() * 360}, 70%, 60%, 0.8)`,
            };
        }
        
        // --- ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨æç”» ---
        function resizeCanvas() {
            // ç”»é¢ã®ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®é«˜ã•ã‚’å–å¾—
            const viewportHeight = window.innerHeight;
            // bodyã®padding (p-4 * 2 = 32px) + gap-4 (16px) ã®ãƒãƒ¼ã‚¸ãƒ³
            const verticalMargin = 48; // 32 + 16

            let availableHeight;
            let containerWidth = gameContainerEl.clientWidth;

            if (window.innerWidth < 768) { // 768px is tailwind's 'md' breakpoint (ãƒ¢ãƒã‚¤ãƒ«ãƒ»ç¸¦)
                const uiPanelHeight = uiPanelEl ? uiPanelEl.offsetHeight : 80;
                availableHeight = viewportHeight - uiPanelHeight - verticalMargin;
            } else { // ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆãƒ»æ¨ª
                availableHeight = viewportHeight - verticalMargin;
                // ã‚³ãƒ³ãƒ†ãƒŠã®å¹…ã‚’å†è¨ˆç®— (md:w-auto, md:max-w-xs ã®ãŸã‚)
                containerWidth = gameContainerEl.clientWidth; 
            }

            // ã‚°ãƒªãƒƒãƒ‰æ•°ã«åŸºã¥ãæœ€å¤§é«˜
            const maxHeightFromGrid = GRID_SIZE * MAX_GRID_ROWS;
            // ä½¿ãˆã‚‹é«˜ã•ã®ä¸Šé™
            const maxHeight = Math.min(availableHeight, maxHeightFromGrid);

            // æ¨ªå¹…ã¯ game-container ã®å¹…ã«åˆã‚ã›ã‚‹
            canvas.width = Math.min(containerWidth, 600); // æœ€å¤§å¹…ã‚‚è¨­å®š

            // é«˜ã•ã¯ã€å¹…*æ¯”ç‡ ã¨ é«˜ã•ä¸Šé™ ã®ã†ã¡å°ã•ã„æ–¹
            const proportionalHeight = canvas.width * 0.75; 
            canvas.height = Math.min(proportionalHeight, maxHeight);
            
            // æœ€å°é«˜ã•ã‚’ä¿è¨¼
            if (canvas.height < 150) canvas.height = 150; 
            
            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®ã‚µã‚¤ã‚ºã‚‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã«åˆã‚ã›ã‚‹
            messageEl.style.width = `${canvas.width}px`;
            messageEl.style.height = `${canvas.height}px`;
        }

        function gameLoop() {
            draw();
            if (gameState.phase !== 'cleared') {
                requestAnimationFrame(gameLoop);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawPolygons();
            drawHighlights();
        }

        function drawGrid() {
            ctx.strokeStyle = '#e2e8f0'; // slate-200
            ctx.lineWidth = 1;
            // æ¨ªç·š (yåº§æ¨™) ã¯ canvas.height ã¾ã§æç”»
            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
             // ç¸¦ç·š (xåº§æ¨™) ã¯ canvas.width ã¾ã§æç”»
            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height); // ç·šã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹ã®é«˜ã•ã¾ã§å¼•ã
                ctx.stroke();
            }
        }

        function drawPolygons() {
            gameState.polygons.forEach(poly => {
                ctx.fillStyle = poly.color;
                ctx.strokeStyle = '#1e293b'; // slate-800
                ctx.lineWidth = 2;
                ctx.beginPath();
                // åº§æ¨™ãŒnull/undefinedã§ãªã„ã“ã¨ã‚’ç¢ºèª
                 if (!poly.vertices || poly.vertices.length === 0 || !poly.vertices[0]) return; 
                const startPos = toCanvasCoords(poly.vertices[0]);
                ctx.moveTo(startPos.x, startPos.y);
                for (let i = 1; i < poly.vertices.length; i++) {
                     if (!poly.vertices[i]) continue; // å¿µã®ãŸã‚
                    const pos = toCanvasCoords(poly.vertices[i]);
                    ctx.lineTo(pos.x, pos.y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
        }
        
        function drawHighlights() {
            if (gameState.phase === 'cut') {
                
                // ã‚«ãƒƒãƒˆãƒ•ã‚§ãƒ¼ã‚ºä¸­ã¯ã™ã¹ã¦ã®é ‚ç‚¹ã‚’å¸¸ã«è¡¨ç¤º
                if (gameState.polygons.length > 0 && gameState.polygons[0]?.vertices) {
                    // ã‚«ãƒƒãƒˆå¯¾è±¡ã¯å¸¸ã«æœ€åˆã®ãƒãƒªã‚´ãƒ³
                    gameState.polygons[0].vertices.forEach(v => {
                         if (!v) return; // å¿µã®ãŸã‚
                        const pos = toCanvasCoords(v);
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.4)'; // blue-500 with alpha
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, VERTEX_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // é¸æŠæ¸ˆã¿ã®é ‚ç‚¹ï¼ˆä¸Šæ›¸ãï¼‰
                gameState.selectedVertices.forEach(vInfo => {
                     if (!vInfo || !vInfo.vertex) return; // å¿µã®ãŸã‚
                    const pos = toCanvasCoords(vInfo.vertex);
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.9)'; // red-500
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, VERTEX_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // ãƒ›ãƒãƒ¼ä¸­ã®é ‚ç‚¹ï¼ˆä¸Šæ›¸ãï¼‰
                if (gameState.hoveredVertex && gameState.hoveredVertex.vertex) {
                     const pos = toCanvasCoords(gameState.hoveredVertex.vertex);
                    ctx.fillStyle = 'rgba(249, 115, 22, 0.9)'; // orange-500
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, VERTEX_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // --- åº§æ¨™å¤‰æ› ---
        function toCanvasCoords(gridPoint) {
             if (!gridPoint) return { x: 0, y: 0 }; // ã‚¨ãƒ©ãƒ¼å›é¿
            return {
                x: gridPoint.x * GRID_SIZE,
                y: gridPoint.y * GRID_SIZE
            };
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© ---
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            // touchend ã®å ´åˆã¯ e.touches[0] ã§ã¯ãªã e.changedTouches[0] ã‚’è¦‹ã‚‹
            const clientX = evt.clientX ?? evt.changedTouches?.[0]?.clientX ?? evt.touches?.[0]?.clientX;
            const clientY = evt.clientY ?? evt.changedTouches?.[0]?.clientY ?? evt.touches?.[0]?.clientY;
            
            // clientX/Y ãŒ null/undefined ã®å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if (clientX === undefined || clientY === undefined) {
                // console.error("Could not get clientX/Y from event:", evt);
                // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†æ™‚ãªã©ã§åº§æ¨™ãŒå–ã‚Œãªã„å ´åˆã¯ã€æœ€å¾Œã®æœ‰åŠ¹ãªåº§æ¨™ã‚’ä½¿ã†ã‹ã€ã‚¨ãƒ©ãƒ¼å›é¿
                return gameState.dragOffset || { x: 0, y: 0 }; // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('touchmove', handleMouseMove);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('touchstart', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('touchend', handleMouseUp);
        window.addEventListener('resize', resizeCanvas);
        
        resetButton.addEventListener('click', () => init(gameState.problemId));
        nextButton.addEventListener('click', goToNextProblem); // ã€Œã¤ãã¸ã€ãƒœã‚¿ãƒ³ã®ãƒªã‚¹ãƒŠãƒ¼

        function setupProblemSelect() {
            const currentSelectedValue = problemSelectEl.value || gameState.problemId || 0; // ç¾åœ¨ã®é¸æŠå€¤ã‚’ä¿æŒ
            problemSelectEl.innerHTML = '';
            problems.forEach((p, index) => {
                const option = document.createElement('option');
                option.value = index;
                const clearMark = problemsClearStatus[index] ? ' â˜…' : ''; // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹é…åˆ—ã‚’å‚ç…§
                option.textContent = p.title + clearMark;
                problemSelectEl.appendChild(option);
            });
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ãŒé‡è¤‡ã—ãªã„ã‚ˆã†ã«ä¸€æ—¦å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ 
            problemSelectEl.removeEventListener('change', handleProblemChange); 
            problemSelectEl.addEventListener('change', handleProblemChange);
            // é¸æŠå€¤ã‚’å¾©å…ƒ
            problemSelectEl.value = currentSelectedValue; 
        }
        
        function handleProblemChange(e) {
             init(parseInt(e.target.value, 10));
        }


        function handleMouseMove(e) {
            // touchmoveæ™‚ã‚‚preventDefaultãŒå¿…è¦
            if (e.type === 'touchmove' || (gameState.phase === 'combine' && gameState.draggedPolygon)) {
                e.preventDefault();
            }
            const mousePos = getMousePos(e);

            if (gameState.phase === 'cut') {
                gameState.hoveredVertex = findVertexAt(mousePos);
            } else if (gameState.phase === 'combine' && gameState.draggedPolygon) {
                 if (!gameState.draggedPolygon.poly?.vertices) return; // ã‚¨ãƒ©ãƒ¼å›é¿
                // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®åº§æ¨™è¨ˆç®— (æµ®å‹•å°æ•°ç‚¹)
                const newVertices = gameState.draggedPolygon.vertices.map(v => ({
                    x: (mousePos.x - gameState.dragOffset.x) / GRID_SIZE + v.original.x,
                    y: (mousePos.y - gameState.dragOffset.y) / GRID_SIZE + v.original.y
                }));
                gameState.draggedPolygon.poly.vertices = newVertices;
            }
        }
        
        function handleMouseDown(e) {
             // touchstartæ™‚ã‚‚preventDefaultãŒå¿…è¦
            if (e.type === 'touchstart') {
                e.preventDefault();
            }
            // ã‚¯ãƒªã‚¢ç”»é¢è¡¨ç¤ºä¸­ã¯æ“ä½œã•ã›ãªã„
            if (gameState.phase === 'cleared') return; 
            
            const mousePos = getMousePos(e);

            if (gameState.phase === 'cut') {
                const clickedVertexInfo = findVertexAt(mousePos);
                if (clickedVertexInfo) {
                    const isAlreadySelected = gameState.selectedVertices.some(v => 
                         v && clickedVertexInfo && // nullãƒã‚§ãƒƒã‚¯
                        v.polygonIndex === clickedVertexInfo.polygonIndex && 
                        v.vertexIndex === clickedVertexInfo.vertexIndex
                    );
                    if (!isAlreadySelected) {
                        gameState.selectedVertices.push(clickedVertexInfo);
                        if (gameState.selectedVertices.length === 2) {
                            // --- åˆ†å‰²å¯å¦ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ  ---
                            if (isValidCut(gameState.selectedVertices[0], gameState.selectedVertices[1])) {
                                // console.log("--- ã‚«ãƒƒãƒˆæœ‰åŠ¹ ---");
                                splitPolygon();
                            } else {
                                // console.log("--- ã‚«ãƒƒãƒˆç„¡åŠ¹ ---");
                                // é¸æŠã‚’ãƒªã‚»ãƒƒãƒˆ
                                gameState.selectedVertices = []; 
                                // ã“ã“ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¡¨ç¤ºã—ã¦ã‚‚è‰¯ã„
                            }
                        }
                    }
                }
            } else if (gameState.phase === 'combine') {
                const clickedPoly = findPolygonAt(mousePos);
                if (clickedPoly) {
                    gameState.dragOffset = mousePos; // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹åº§æ¨™ã‚’ä¿å­˜
                    gameState.draggedPolygon = {
                        poly: clickedPoly,
                        // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®æ•´æ•°åº§æ¨™ã‚’ä¿å­˜
                        vertices: clickedPoly.vertices.map(v => ({ original: {...v} }))
                    };
                }
            }
        }
        
        // --- handleMouseUp ã®ä¿®æ­£ (ã‚¿ãƒƒãƒå¯¾å¿œã€ã‚¹ãƒŠãƒƒãƒ—ãƒ­ã‚¸ãƒƒã‚¯æ”¹å–„) ---
        function handleMouseUp(e) {
             // ã‚¯ãƒªã‚¢ç”»é¢è¡¨ç¤ºä¸­ã¯æ“ä½œã•ã›ãªã„
            if (gameState.phase === 'cleared') return; 
            
            if (gameState.phase === 'combine' && gameState.draggedPolygon) {
                const poly = gameState.draggedPolygon.poly;
                
                // poly.vertices ãŒå­˜åœ¨ã—ã€è¦ç´ ãŒã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                if (!poly.vertices || poly.vertices.length === 0) {
                     // console.error("Dragged polygon has no vertices on mouse/touch end.");
                     gameState.draggedPolygon = null; // Reset drag state
                     return; 
                }

                // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†æ™‚ã®å›³å½¢ã®ã€Œç¾åœ¨ã®ã€æµ®å‹•å°æ•°ç‚¹åº§æ¨™ã‚’å–å¾—
                 // Handle potential undefined vertices during drag
                const currentVertices = poly.vertices.map(v => v ? {...v} : null).filter(v => v !== null); 
                
                if (currentVertices.length > 0) {
                    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®æœ€åˆã®é ‚ç‚¹ã®åº§æ¨™
                    const firstVertexOriginal = gameState.draggedPolygon.vertices[0].original;
                    // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†æ™‚ã®ãƒã‚¦ã‚¹åº§æ¨™
                    const finalMousePos = getMousePos(e);
                    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®ãƒã‚¦ã‚¹åº§æ¨™
                    const startMousePos = gameState.dragOffset;
                    
                    // ã‚¿ãƒƒãƒçµ‚äº†æ™‚(touchend)ã§ finalMousePos ãŒ 0,0 ã«ãªã‚‹ã‚±ãƒ¼ã‚¹ã®å¯¾ç­–
                    if (e.type === 'touchend' && finalMousePos.x === 0 && finalMousePos.y === 0) {
                        // console.warn("touchend event did not provide coordinates, using last drag offset.");
                        // ã“ã®å ´åˆã€ã‚¹ãƒŠãƒƒãƒ—ãŒã†ã¾ãæ©Ÿèƒ½ã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚‹ãŒã€
                        // å¤šãã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ changedTouches[0] ãŒä½¿ãˆã‚‹ã¯ãš
                         if (gameState.dragOffset.x === 0 && gameState.dragOffset.y === 0) {
                             // startMousePos ã‚‚ 0,0 ã ã£ãŸå ´åˆã€ã©ã†ã—ã‚ˆã†ã‚‚ãªã„ã®ã§ã‚¹ãƒŠãƒƒãƒ—ã—ãªã„
                         }
                    }


                    // ã‚°ãƒªãƒƒãƒ‰å˜ä½ã§ã®ç·ç§»å‹•è·é›¢ã‚’è¨ˆç®—
                    const gridDx = Math.round((finalMousePos.x - startMousePos.x) / GRID_SIZE);
                    const gridDy = Math.round((finalMousePos.y - startMousePos.y) / GRID_SIZE);

                    // ã™ã¹ã¦ã®é ‚ç‚¹ã«ã€ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®æ•´æ•°åº§æ¨™ + æ•´æ•°ã®ç§»å‹•è·é›¢ ã‚’é©ç”¨
                    poly.vertices.forEach((v, index) => {
                         if (v) { // null ãƒã‚§ãƒƒã‚¯
                            const originalV = gameState.draggedPolygon.vertices[index].original;
                            v.x = originalV.x + gridDx;
                            v.y = originalV.y + gridDy;
                         }
                    });
                } else {
                     // console.error("No valid vertices found after drag.");
                }


                checkWinCondition();
                gameState.draggedPolygon = null;
            }
        }


        // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ ---

        function findVertexAt(pos) {
            // ã‚«ãƒƒãƒˆãƒ•ã‚§ãƒ¼ã‚ºã§ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
             if (gameState.phase !== 'cut' || !gameState.polygons || gameState.polygons.length === 0 || !gameState.polygons[0]?.vertices) {
                return null;
            }
            // ã‚«ãƒƒãƒˆå¯¾è±¡ã¯å¸¸ã«æœ€åˆã®ãƒãƒªã‚´ãƒ³
            const poly = gameState.polygons[0]; 
            for (let j = 0; j < poly.vertices.length; j++) {
                const v = poly.vertices[j];
                 if (!v) continue; // null ãƒã‚§ãƒƒã‚¯
                const vPos = toCanvasCoords(v);
                const dist = Math.hypot(vPos.x - pos.x, vPos.y - pos.y);
                if (dist < CLICK_RADIUS) { // <<< åˆ¤å®šç¯„å›²ã‚’ CLICK_RADIUS ã«å¤‰æ›´
                    // ã‚«ãƒƒãƒˆå¯¾è±¡ãƒãƒªã‚´ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯å¸¸ã«0
                    return { polygonIndex: 0, vertexIndex: j, vertex: v }; 
                }
            }
            return null;
        }
        
        function findPolygonAt(pos) {
            for (let i = gameState.polygons.length - 1; i >= 0; i--) {
                const poly = gameState.polygons[i];
                 if (!poly?.vertices || poly.vertices.length < 1 || !poly.vertices[0]) continue; // å®‰å…¨ãƒã‚§ãƒƒã‚¯
                ctx.beginPath();
                const startPos = toCanvasCoords(poly.vertices[0]);
                ctx.moveTo(startPos.x, startPos.y);
                for (let j = 1; j < poly.vertices.length; j++) {
                     if (!poly.vertices[j]) continue; // å®‰å…¨ãƒã‚§ãƒƒã‚¯
                    const p = toCanvasCoords(poly.vertices[j]);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
                if (ctx.isPointInPath(pos.x, pos.y)) {
                    return poly;
                }
            }
            return null;
        }

        /**
         * é ‚ç‚¹ãƒªã‚¹ãƒˆã‹ã‚‰ã€éš£æ¥ã™ã‚‹é ‚ç‚¹ã¨ç›´ç·šä¸Šã«ã‚ã‚‹ä¸­é–“é ‚ç‚¹ã‚’å‰Šé™¤ã™ã‚‹
         * @param {Array<object>} vertices - é ‚ç‚¹ã®é…åˆ—
         * @returns {Array<object>} å˜ç´”åŒ–ã•ã‚ŒãŸé ‚ç‚¹ã®é…åˆ—
         */
        function simplifyPolygon(vertices) {
            if (!vertices || vertices.length < 3) {
                return vertices || []; // null/undefined ã¾ãŸã¯å°‘ãªã™ãã‚‹å ´åˆã¯ãã®ã¾ã¾è¿”ã™
            }
            const simplified = [];
            const n = vertices.length;
            for (let i = 0; i < n; i++) {
                const p_prev = vertices[(i - 1 + n) % n];
                const p_curr = vertices[i];
                const p_next = vertices[(i + 1) % n];
                
                // null/undefined ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
                if (!p_prev || !p_curr || !p_next) continue;

                // ç¾åœ¨ã®ç‚¹ãŒéš£æ¥ã™ã‚‹ç‚¹ã¨ä¸€ç›´ç·šä¸Šã§ãªã‘ã‚Œã°ã€çœŸã®é ‚ç‚¹ã¨ã—ã¦ä¿æŒã™ã‚‹
                if (getOrientation(p_prev, p_curr, p_next) !== 0) {
                    simplified.push(p_curr);
                }
            }
            // é ‚ç‚¹ãŒ2ã¤ä»¥ä¸‹ã«ãªã£ãŸå ´åˆã¯å…ƒã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ï¼ˆç¸®é€€ã‚’é¿ã‘ã‚‹ï¼‰
            return simplified.length < 3 ? vertices : simplified;
        }


        function splitPolygon() {
            const v1Info = gameState.selectedVertices[0];
            const v2Info = gameState.selectedVertices[1];
            
            // isValidCut ã§ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ã®ã¯ãšã ãŒå¿µã®ãŸã‚
            if (!v1Info || !v2Info || v1Info.polygonIndex !== v2Info.polygonIndex || !gameState.polygons[v1Info.polygonIndex]?.vertices) { 
                gameState.selectedVertices = [];
                return;
            }

            const originalPoly = gameState.polygons[v1Info.polygonIndex];
            const vertices = originalPoly.vertices;
            
            let idx1 = v1Info.vertexIndex;
            let idx2 = v2Info.vertexIndex;

            if (idx1 > idx2) [idx1, idx2] = [idx2, idx1];

            const newVertices1 = [];
            for (let i = idx1; i <= idx2; i++) {
                 if (vertices[i]) newVertices1.push(vertices[i]); // null ãƒã‚§ãƒƒã‚¯
            }
            
            const newVertices2 = [];
            for (let i = idx2; i < vertices.length; i++) {
                 if (vertices[i]) newVertices2.push(vertices[i]); // null ãƒã‚§ãƒƒã‚¯
            }
            for (let i = 0; i <= idx1; i++) {
                 if (vertices[i]) newVertices2.push(vertices[i]); // null ãƒã‚§ãƒƒã‚¯
            }
            
            const simplified1 = simplifyPolygon(newVertices1);
            const simplified2 = simplifyPolygon(newVertices2);

            // åˆ†å‰²å¾Œã®ãƒãƒªã‚´ãƒ³ãŒæœ‰åŠ¹ã‹ï¼ˆé ‚ç‚¹ãŒ3ã¤ä»¥ä¸Šã‚ã‚‹ã‹ï¼‰ãƒã‚§ãƒƒã‚¯
             if (!simplified1 || simplified1.length < 3 || !simplified2 || simplified2.length < 3) {
                // console.warn("åˆ†å‰²ã«ã‚ˆã‚Šç„¡åŠ¹ãªãƒãƒªã‚´ãƒ³ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚ã‚«ãƒƒãƒˆã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™ã€‚");
                gameState.selectedVertices = [];
                return;
            }

            gameState.polygons = [
                createPolygon(simplified1),
                createPolygon(simplified2),
            ];
            gameState.phase = 'combine';
            // ãƒ•ã‚§ãƒ¼ã‚ºè¡¨ç¤ºå‰Šé™¤
            gameState.selectedVertices = []; // é¸æŠè§£é™¤
        }
        
        // 3ç‚¹ã®å‘ãã‚’èª¿ã¹ã‚‹
        function getOrientation(p, q, r) {
             // null/undefined ãƒã‚§ãƒƒã‚¯
             if (!p || !q || !r) return 0; // ä¸æ­£ãªå…¥åŠ›ã¯åŒä¸€ç›´ç·šæ‰±ã„
            // æµ®å‹•å°æ•°ç‚¹ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€è¨±å®¹èª¤å·®ã‚’è¨­å®š
            const epsilon = 0.001; 
            const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            if (Math.abs(val) < epsilon) return 0; // åŒä¸€ç›´ç·šä¸Š
            return (val > 0) ? 1 : 2; // æ™‚è¨ˆå›ã‚Š or åæ™‚è¨ˆå›ã‚Š
        }
        
        // --- ã‚«ãƒƒãƒˆæœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯é–¢æ•° ---
        function isValidCut(v1Info, v2Info) {
            // console.log("--- ã‚«ãƒƒãƒˆæœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯é–‹å§‹ ---");
            // null ãƒã‚§ãƒƒã‚¯
             if (!v1Info || !v2Info || !v1Info.vertex || !v2Info.vertex) {
                // console.log("ã‚¨ãƒ©ãƒ¼: é¸æŠã•ã‚ŒãŸé ‚ç‚¹æƒ…å ±ãŒç„¡åŠ¹ã§ã™ã€‚");
                return false;
             }
            // ã‚«ãƒƒãƒˆå¯¾è±¡ã¯å¸¸ã«æœ€åˆã®ãƒãƒªã‚´ãƒ³
            if (v1Info.polygonIndex !== 0 || v2Info.polygonIndex !== 0) {
                // console.log("ã‚¨ãƒ©ãƒ¼: ã‚«ãƒƒãƒˆå¯¾è±¡ã®ãƒãƒªã‚´ãƒ³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒä¸æ­£ã§ã™ã€‚");
                return false; 
            }
            const polygon = gameState.polygons[0];
            // null ãƒã‚§ãƒƒã‚¯
             if (!polygon?.vertices) {
                 // console.log("ã‚¨ãƒ©ãƒ¼: ã‚«ãƒƒãƒˆå¯¾è±¡ã®ãƒãƒªã‚´ãƒ³ã¾ãŸã¯é ‚ç‚¹ãƒªã‚¹ãƒˆãŒç„¡åŠ¹ã§ã™ã€‚");
                 return false;
             }
            const vertices = polygon.vertices.filter(v => v !== null); // nullã‚’é™¤å»
            const n = vertices.length;
            let idx1 = v1Info.vertexIndex;
            let idx2 = v2Info.vertexIndex;
            const p1 = v1Info.vertex;
            const p2 = v2Info.vertex;
            
            if (idx1 === idx2) {
                 // console.log("ãƒã‚§ãƒƒã‚¯å¤±æ•—: åŒã˜é ‚ç‚¹ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™ã€‚");
                 return false; // åŒã˜ç‚¹ã¯é¸ã¹ãªã„
            }

            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ˜‡é †ã« (ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã†)
            const original_idx1 = v1Info.vertexIndex;
            const original_idx2 = v2Info.vertexIndex;
             if (original_idx1 > original_idx2) {
                idx1 = original_idx2;
                idx2 = original_idx1;
             } else {
                 idx1 = original_idx1;
                 idx2 = original_idx2;
             }


            // 1. éš£æ¥ãƒã‚§ãƒƒã‚¯
             const original_n = polygon.vertices.length; // å…ƒã®é ‚ç‚¹æ•°ã§ãƒã‚§ãƒƒã‚¯
            const areAdjacent = (idx2 === idx1 + 1) || (idx1 === 0 && idx2 === original_n - 1);
            // console.log(`1. éš£æ¥ãƒã‚§ãƒƒã‚¯: é¸æŠã•ã‚ŒãŸé ‚ç‚¹ã¯éš£æ¥ã—ã¦ã„ã‚‹ã‹ï¼Ÿ -> ${areAdjacent}`);
            if (areAdjacent) {
                // console.log("   ...åˆ†å‰²ä¸å¯ (éš£æ¥ã™ã‚‹é ‚ç‚¹)");
                return false;
            }

            // 2. ç·šä¸Šãƒã‚§ãƒƒã‚¯ (ä¿®æ­£: é–“ã«ã‚ã‚‹é ‚ç‚¹ã® *ã©ã‚Œã‹1ã¤ã§ã‚‚* ç·šä¸Šã«ã‚ã‚Œã°åˆ†å‰²ä¸å¯)
            let anyIntermediateCollinear = false;
            // console.log(`2. ç·šä¸Šãƒã‚§ãƒƒã‚¯: é–“ã«ã‚ã‚‹é ‚ç‚¹ã®ã„ãšã‚Œã‹ãŒç·šåˆ†ä¸Šã«ã‚ã‚‹ã‹ï¼Ÿ`);
            // idx1ã‹ã‚‰idx2ã¸ã®çµŒè·¯ (å…ƒã®é ‚ç‚¹ãƒªã‚¹ãƒˆã§)
            for (let i = idx1 + 1; i < idx2; i++) {
                const intermediateVertex = polygon.vertices[i];
                 if (!intermediateVertex) continue; // null ã‚¹ã‚­ãƒƒãƒ—
                if (onSegment(p1, intermediateVertex, p2)) {
                    anyIntermediateCollinear = true;
                    // console.log(`   ...é ‚ç‚¹ ${i} (${intermediateVertex.x}, ${intermediateVertex.y}) ã¯ç·šåˆ†ä¸Šã«ã‚ã‚Šã¾ã™ (çµŒè·¯1)ã€‚`);
                    break; 
                } else {
                     // console.log(`   ...é ‚ç‚¹ ${i} (${intermediateVertex.x}, ${intermediateVertex.y}) ã¯ç·šåˆ†ä¸Šã«ã‚ã‚Šã¾ã›ã‚“ (çµŒè·¯1)ã€‚`);
                }
            }
            // idx2ã‹ã‚‰idx1ã¸ã®çµŒè·¯ (ãƒ©ãƒƒãƒ—ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰, å…ƒã®é ‚ç‚¹ãƒªã‚¹ãƒˆã§)
            if (!anyIntermediateCollinear) { // æœ€åˆã®çµŒè·¯ã§ç·šä¸Šé ‚ç‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯
                 for (let i = (idx2 + 1) % original_n; i !== idx1; i = (i + 1) % original_n) {
                     const intermediateVertex = polygon.vertices[i];
                      if (!intermediateVertex) continue; // null ã‚¹ã‚­ãƒƒãƒ—
                     if (onSegment(p1, intermediateVertex, p2)) {
                         anyIntermediateCollinear = true;
                         // console.log(`   ...é ‚ç‚¹ ${i} (${intermediateVertex.x}, ${intermediateVertex.y}) ã¯ç·šåˆ†ä¸Šã«ã‚ã‚Šã¾ã™ (çµŒè·¯2)ã€‚`);
                         break;
                     } else {
                          // console.log(`   ...é ‚ç‚¹ ${i} (${intermediateVertex.x}, ${intermediateVertex.y}) ã¯ç·šåˆ†ä¸Šã«ã‚ã‚Šã¾ã›ã‚“ (çµŒè·¯2)ã€‚`);
                     }
                 }
            }
             // console.log(`   -> çµæœ: ${anyIntermediateCollinear}`);
            if (anyIntermediateCollinear) {
                // console.log("   ...åˆ†å‰²ä¸å¯ (ä¸­é–“ã®é ‚ç‚¹ã®ã„ãšã‚Œã‹ãŒåŒä¸€ç›´ç·šä¸Š)");
                return false;
            }


            // 3. äº¤å·®ãƒã‚§ãƒƒã‚¯ (ç·šåˆ†p1-p2ãŒä»–ã®è¾ºã¨äº¤å·®ã™ã‚‹ã‹)
            let intersectsOtherEdge = false;
            // console.log(`3. äº¤å·®ãƒã‚§ãƒƒã‚¯ (ã‚«ãƒƒãƒˆç·šåˆ†: (${p1.x},${p1.y})-(${p2.x},${p2.y}))`);
            for (let i = 0; i < original_n; i++) {
                const edgeP1 = polygon.vertices[i];
                const edgeP2 = polygon.vertices[(i + 1) % original_n];
                
                // null ãƒã‚§ãƒƒã‚¯
                if (!edgeP1 || !edgeP2) continue;

                // ã‚«ãƒƒãƒˆç·šåˆ†ã®ç«¯ç‚¹ã‚’å«ã‚€è¾ºã¯ãƒã‚§ãƒƒã‚¯å¯¾è±¡å¤–
                 if (i === idx1 || (i + 1) % original_n === idx1 || i === idx2 || (i + 1) % original_n === idx2) {
                     // console.log(`   ...è¾º ${i} (${edgeP1.x},${edgeP1.y})-(${edgeP2.x},${edgeP2.y}) ã¯é¸æŠç‚¹ã‚’å«ã‚€ãŸã‚ã‚¹ã‚­ãƒƒãƒ—`);
                     continue; 
                 }

                if (doSegmentsIntersect(p1, p2, edgeP1, edgeP2)) {
                    intersectsOtherEdge = true;
                     // console.log(`   ...è¾º ${i} (${edgeP1.x},${edgeP1.y})-(${edgeP2.x},${edgeP2.y}) ã¨äº¤å·®ã—ã¾ã—ãŸã€‚`);
                    break;
                }
            }
            // console.log(`   -> çµæœ: ${intersectsOtherEdge}`);
            if (intersectsOtherEdge) {
                // console.log("   ...åˆ†å‰²ä¸å¯ (ã‚«ãƒƒãƒˆç·šãŒä»–ã®è¾ºã¨äº¤å·®)");
                return false;
            }
            
            // 4. å†…éƒ¨ç·šåˆ†ãƒã‚§ãƒƒã‚¯ (ä¿®æ­£: ç·šåˆ†p1-p2ã®ä¸­ç‚¹ãŒãƒãƒªã‚´ãƒ³ã®å³å¯†ãªå†…éƒ¨ã«ã‚ã‚‹ã‹ï¼Ÿ trueãªã‚‰åˆ†å‰²å¯)
            const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            // console.log(`4. å†…éƒ¨ç·šåˆ†ãƒã‚§ãƒƒã‚¯ (ä¸­ç‚¹: (${midPoint.x}, ${midPoint.y}))`);
            
            // isPointStrictlyInside ã¯æµ®å‹•å°æ•°ç‚¹ã«å¯¾å¿œã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ã“ã“ã§åˆ¤å®š
            let midPointOnEdge = false;
            for (let i = 0; i < original_n; i++) {
                 const edgeP1 = polygon.vertices[i];
                 const edgeP2 = polygon.vertices[(i + 1) % original_n];
                  if (!edgeP1 || !edgeP2) continue; // null ãƒã‚§ãƒƒã‚¯
                 if (onSegment(edgeP1, midPoint, edgeP2)) {
                      midPointOnEdge = true;
                      // console.log(`   ...ä¸­ç‚¹ãŒè¾º ${i} (${edgeP1.x},${edgeP1.y})-(${edgeP2.x},${edgeP2.y}) ä¸Šã«ã‚ã‚Šã¾ã™ã€‚`);
                      break;
                 }
            }
            
            // isPointInPath ã‚’ä½¿ã£ã¦å†…éƒ¨ãƒ»å¢ƒç•Œä¸Šåˆ¤å®š
             ctx.beginPath(); // isPointInPath ã®ãŸã‚ã«ãƒ‘ã‚¹ã‚’å†æ§‹ç¯‰
             const startPos = toCanvasCoords(polygon.vertices[0]);
             ctx.moveTo(startPos.x, startPos.y);
             for (let j = 1; j < original_n; j++) {
                 const pt = toCanvasCoords(polygon.vertices[j]);
                 if (pt) ctx.lineTo(pt.x, pt.y); // null ãƒã‚§ãƒƒã‚¯
             }
             ctx.closePath();
            const midPointCanvas = toCanvasCoords(midPoint);
            const isMidpointInsideOrOnEdge = ctx.isPointInPath(midPointCanvas.x, midPointCanvas.y); 
            
            // å³å¯†ã«å†…éƒ¨ã«ã‚ã‚‹ã®ã¯ã€isPointInPathãŒtrueã§ã€ã‹ã¤ã©ã®è¾ºä¸Šã«ã‚‚ãªã„å ´åˆ
            const isMidpointStrictlyInside = isMidpointInsideOrOnEdge && !midPointOnEdge;
            
            // console.log(`   -> ä¸­ç‚¹ã¯è¾ºä¸Šã«ã‚ã‚‹ã‹: ${midPointOnEdge}`);
            // console.log(`   -> ä¸­ç‚¹ã¯å†…éƒ¨ã¾ãŸã¯è¾ºä¸Šã«ã‚ã‚‹ã‹ (isPointInPath): ${isMidpointInsideOrOnEdge}`);
            // console.log(`   -> çµæœ (å³å¯†ã«å†…éƒ¨ã«ã‚ã‚‹ã‹): ${isMidpointStrictlyInside}`);
            
            // ä¿®æ­£: å³å¯†ã«å†…éƒ¨ã« *ãªã‘ã‚Œã°* åˆ†å‰²ä¸å¯
            if (!isMidpointStrictlyInside) {
                // console.log("   ...åˆ†å‰²ä¸å¯ (ã‚«ãƒƒãƒˆç·šãŒå†…éƒ¨ã‚’é€šéã—ãªã„, å¤–éƒ¨ã¾ãŸã¯è¾ºä¸Š)");
                return false;
            }

            // ã™ã¹ã¦ã®ã€Œåˆ†å‰²ä¸å¯ã€æ¡ä»¶ã«å½“ã¦ã¯ã¾ã‚‰ãªã‘ã‚Œã°åˆ†å‰²å¯
            return true; 
        }


        // --- æ–°ã—ã„ã‚¯ãƒªã‚¢åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ (ã“ã“ã‹ã‚‰) ---

        // æœ€å¤§å…¬ç´„æ•° (GCD) ã‚’è¨ˆç®—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        // 2ç‚¹é–“ã®æ ¼å­ç‚¹ã‚’ãŸã©ã‚Šã€å˜ä½æœ‰å‘è¾ºã‚’ã‚»ãƒƒãƒˆã«è¿½åŠ ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
        function addUnitEdgesBetween(p1, p2, edgeSet) {
             if (!p1 || !p2) return; // null ãƒã‚§ãƒƒã‚¯
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            
            if (dx === 0 && dy === 0) return;

            // ä¿®æ­£: GCDã‚’ä½¿ã£ã¦æœ€çŸ­ã®æ ¼å­ç‚¹ãƒ™ã‚¯ãƒˆãƒ«ã«åˆ†è§£ã™ã‚‹
            const commonDivisor = gcd(Math.abs(dx), Math.abs(dy));
            const ux = dx / commonDivisor; // å˜ä½ãƒ™ã‚¯ãƒˆãƒ«ã®xæˆåˆ† (æ•´æ•°)
            const uy = dy / commonDivisor; // å˜ä½ãƒ™ã‚¯ãƒˆãƒ«ã®yæˆåˆ† (æ•´æ•°)
            const len = commonDivisor;     // åˆ†è§£å¾Œã®è¾ºã®æ•°

            for (let i = 0; i < len; i++) {
                const x1 = p1.x + i * ux;
                const y1 = p1.y + i * uy;
                const x2 = p1.x + (i + 1) * ux;
                const y2 = p1.y + (i + 1) * uy;
                // åº§æ¨™ã¯ã™ã¹ã¦æ•´æ•°ã«ãªã‚‹
                edgeSet.add(`${x1},${y1},${x2},${y2}`);
            }
        }

        // å¤šè§’å½¢ã®é ‚ç‚¹ãƒªã‚¹ãƒˆã‹ã‚‰å˜ä½æœ‰å‘è¾ºã‚»ãƒƒãƒˆã‚’ä½œæˆ
        function getUnitEdges(vertices) {
             if (!vertices) return new Set(); // null ãƒã‚§ãƒƒã‚¯
            const edgeSet = new Set();
            const validVertices = vertices.filter(v => v !== null); // null ã‚’é™¤å»
            const n = validVertices.length;
            for (let i = 0; i < n; i++) {
                const p1 = validVertices[i];
                const p2 = validVertices[(i + 1) % n];
                addUnitEdgesBetween(p1, p2, edgeSet);
            }
            return edgeSet;
        }

        // å˜ä½æœ‰å‘è¾ºã‚»ãƒƒãƒˆã®é€†å‘ãã‚»ãƒƒãƒˆã‚’ä½œæˆ
        function getReversedEdges(edgeSet) {
            const reversedSet = new Set();
            for (const edge of edgeSet) {
                const [x1, y1, x2, y2] = edge.split(',').map(Number);
                reversedSet.add(`${x2},${y2},${x1},${y1}`);
            }
            return reversedSet;
        }
        
        // ç·šåˆ†qãŒç·šåˆ†prä¸Šã«ã‚ã‚‹ã‹ (ç«¯ç‚¹ã‚’å«ã‚€)
        // onSegment ã¯ isValidCut ã§ã‚‚ä½¿ç”¨ã™ã‚‹ãŸã‚ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«ç§»å‹•

        // ç·šåˆ†qãŒç·šåˆ†prä¸Šã«ã‚ã‚‹ã‹ (ç«¯ç‚¹ã‚’é™¤ã)
        function onSegmentStrict(p, q, r) {
             if (!p || !q || !r) return false; // null ãƒã‚§ãƒƒã‚¯
            // qãŒpã¾ãŸã¯rã¨ä¸€è‡´ã™ã‚‹å ´åˆã¯false
            if ((q.x === p.x && q.y === p.y) || (q.x === r.x && q.y === r.y)) {
                return false;
            }
            return onSegment(p, q, r);
        }

        // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒ†ã‚£ãƒ³ã‚°æ³•ã«ã‚ˆã‚‹ç‚¹ã®å†…éƒ¨åˆ¤å®šï¼ˆå³å¯†ã«å†…éƒ¨ï¼‰
        function isPointStrictlyInside(point, polygonVertices) {
             if (!point || !polygonVertices || polygonVertices.length < 3) return false; // null ãƒã‚§ãƒƒã‚¯
            // console.log(`  isPointStrictlyInside: ç‚¹ (${point.x}, ${point.y}) ã‚’ãƒã‚§ãƒƒã‚¯ä¸­...`);
            const x = point.x, y = point.y;
            let isInside = false;
            const validVertices = polygonVertices.filter(v => v !== null); // null ã‚’é™¤å»
            const n = validVertices.length;

            for (let i = 0, j = n - 1; i < n; j = i++) {
                const xi = validVertices[i].x, yi = validVertices[i].y;
                const xj = validVertices[j].x, yj = validVertices[j].y;
                
                // é ‚ç‚¹ä¸Šã«ã‚ã‚‹
                if (xi === x && yi === y) {
                    // console.log(`    ...é ‚ç‚¹ (${xi}, ${yi}) ã®ä¸Šã«ã‚ã‚Šã¾ã™ã€‚ [çµæœ: å†…éƒ¨ã§ã¯ãªã„]`);
                    return false;
                }
                
                // è¾ºä¸Šã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ (åŒä¸€ç›´ç·šã‹ã¤ç¯„å›²å†…)
                if (onSegment({x:xi, y:yi}, point, {x:xj, y:yj})) {
                     // console.log(`    ...è¾º (${xi}, ${yi})-(${xj}, ${yj}) ã®ä¸Šã«ã‚ã‚Šã¾ã™ã€‚ [çµæœ: å†…éƒ¨ã§ã¯ãªã„]`);
                     return false; // å¢ƒç•Œä¸Š
                }
                
                // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒ†ã‚£ãƒ³ã‚° (æ°´å¹³ãƒ¬ã‚¤: (x, y) ã‹ã‚‰ +Xæ–¹å‘)
                // è¾º (xi, yi) - (xj, yj) ã¨äº¤å·®ã™ã‚‹ã‹ï¼Ÿ
                // å§‹ç‚¹ã‚’å«ã¿ã€çµ‚ç‚¹ã‚’å«ã¾ãªã„ (yi <= y < yj) ã¾ãŸã¯ (yj <= y < yi)
                const y_crosses = ((yi <= y && y < yj) || (yj <= y && y < yi));

                if (y_crosses) {
                    // x < x_intersect ?
                    // æµ®å‹•å°æ•°ç‚¹ã‚’é¿ã‘ã‚‹ãŸã‚ã€å¤–ç©(getOrientation)ã§å·¦å³ã‚’åˆ¤å®š
                    const orientation = getOrientation({x:xi, y:yi}, {x:xj, y:yj}, point);

                    if (yj > yi) { // ä¸Šå‘ãã®è¾º (yi <= y < yj)
                         if (orientation === 2) { // pointãŒå·¦å´ (ãƒ¬ã‚¤ãŒäº¤å·®)
                            // console.log(`    ...ãƒ¬ã‚¤ãŒä¸Šå‘ãã®è¾º (${xi}, ${yi})-(${xj}, ${yj}) ã¨äº¤å·®ã—ã¾ã—ãŸã€‚`);
                            isInside = !isInside;
                         }
                     } else { // ä¸‹å‘ãã®è¾º (yj <= y < yi)
                         if (orientation === 1) { // pointãŒå³å´ (ãƒ¬ã‚¤ãŒäº¤å·®)
                             // console.log(`    ...ãƒ¬ã‚¤ãŒä¸‹å‘ãã®è¾º (${xi}, ${yi})-(${xj}, ${yj}) ã¨äº¤å·®ã—ã¾ã—ãŸã€‚`);
                             isInside = !isInside;
                         }
                     }
                }
            }
            // console.log(`  isPointStrictlyInside: æœ€çµ‚çµæœ: ${isInside}`);
            return isInside;
        }
        

        // 2ã¤ã®ç·šåˆ† (p1, q1) ã¨ (p2, q2) ãŒç«¯ç‚¹ä»¥å¤–ã§äº¤å·®ã™ã‚‹ã‹
        // (ä¿®æ­£ç‰ˆ: äº¤ç‚¹è¨ˆç®— + å³å¯†ãªå†…éƒ¨åˆ¤å®š)
        function doSegmentsIntersect(p1, q1, p2, q2) {
             // null ãƒã‚§ãƒƒã‚¯
             if (!p1 || !q1 || !p2 || !q2) return false; 
            // console.log(`  doSegmentsIntersect: è¾º (${p1.x},${p1.y})-(${q1.x},${q1.y}) vs è¾º (${p2.x},${p2.y})-(${q2.x},${q2.y})`);

            const dx1 = q1.x - p1.x;
            const dy1 = q1.y - p1.y;
            const dx2 = q2.x - p2.x;
            const dy2 = q2.y - p2.y;
            const dx3 = p1.x - p2.x; // p1 - p2 ã® x æˆåˆ†
            const dy3 = p1.y - p2.y; // p1 - p2 ã® y æˆåˆ†

            const det = dx1 * dy2 - dx2 * dy1; // Integer calculation

            if (det === 0) {
                // Lines are parallel or collinear
                // checkOverlap ã®å½¹å‰²ã¯ã€Œé£Ÿã„è¾¼ã¿ã€ã‚„ã€Œåå­—äº¤å·®ã€ã®æ¤œå‡ºãªã®ã§ã€
                // å¹³è¡Œãƒ»åŒä¸€ç›´ç·šä¸Šã®å ´åˆã¯ã€Œäº¤å·®ã§ã¯ãªã„ã€ã¨ã—ã¦ false ã‚’è¿”ã™
                // console.log("    ...[çµæœ: false] (å¹³è¡Œã¾ãŸã¯åŒä¸€ç›´ç·šä¸Š)");
                return false;
            } else {
                // Lines intersect at a point
                // Corrected formula for num_t
                const num_t = dx2 * dy3 - dx3 * dy2; // This corresponds to cross(s, q) where q = p1-p2
                const num_u = dx1 * dy3 - dy1 * dx3; // This corresponds to cross(r, q) where q = p1-p2

                // console.log(`    ...Lines intersect (det=${det}, num_t=${num_t}, num_u=${num_u})`);

                // Check if intersection point is strictly within both segments (0 < t < 1 and 0 < u < 1)
                // Using integer comparison to avoid floating point issues
                let t_in_range = false;
                let u_in_range = false;

                // Check sign consistency for t = num_t / det
                if (det > 0) {
                    t_in_range = num_t > 0 && num_t < det;
                } else { // det < 0
                    t_in_range = num_t < 0 && num_t > det; // Check if det < num_t < 0
                }

                // Check sign consistency for u = num_u / det 
                if (det > 0) {
                     u_in_range = num_u > 0 && num_u < det;
                } else { // det < 0
                     u_in_range = num_u < 0 && num_u > det; // Check if det < num_u < 0
                }
                
                // console.log(`    ...Range check: t_in_range=${t_in_range}, u_in_range=${u_in_range}`);

                if (t_in_range && u_in_range) {
                    // console.log("    ...[çµæœ: true] (Intersection point is strictly within both segments)");
                    return true; // Intersection point is strictly within both segments
                } else {
                    // console.log("    ...[çµæœ: false] (Intersection point is outside one or both segments, or on an endpoint)");
                    return false; // Intersection point is outside one or both segments, or on an endpoint (T-junction etc.)
                }
            }
        }

        // ãƒã‚§ãƒƒã‚¯1: é‡ãªã‚Šåˆ¤å®š
        function checkOverlap(poly1, poly2) {
             if (!poly1?.vertices || !poly2?.vertices || poly1.vertices.length < 3 || poly2.vertices.length < 3) return true; // Invalid polygon is considered overlapping
            const validVertices1 = poly1.vertices.filter(v => v !== null);
            const validVertices2 = poly2.vertices.filter(v => v !== null);
             if (validVertices1.length < 3 || validVertices2.length < 3) return true; // Not enough valid vertices

            // console.log("  ã€ãƒã‚§ãƒƒã‚¯1ã€‘é‡ãªã‚Šåˆ¤å®š (checkOverlap) é–‹å§‹");
            
            // å†…éƒ¨é ‚ç‚¹åˆ¤å®š (P1ã®é ‚ç‚¹ãŒP2ã®å†…éƒ¨ã«ã‚ã‚‹ã‹)
            // console.log("  ...P1ã®é ‚ç‚¹ãŒP2ã®å†…éƒ¨ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯");
            if (isPointStrictlyInside(validVertices1[0], validVertices2)) {
                // console.log("    ...[çµæœ: é‡ãªã£ã¦ã„ã‚‹] (P1ã®é ‚ç‚¹ãŒP2ã®å†…éƒ¨)");
                return true; // Overlaps = True
            }
            
            // å†…éƒ¨é ‚ç‚¹åˆ¤å®š (P2ã®é ‚ç‚¹ãŒP1ã®å†…éƒ¨ã«ã‚ã‚‹ã‹)
            // console.log("  ...P2ã®é ‚ç‚¹ãŒP1ã®å†…éƒ¨ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯");
            if (isPointStrictlyInside(validVertices2[0], validVertices1)) {
                // console.log("    ...[çµæœ: é‡ãªã£ã¦ã„ã‚‹] (P2ã®é ‚ç‚¹ãŒP1ã®å†…éƒ¨)");
                return true; // Overlaps = True
            }
            
            // è¾ºã®äº¤å·®åˆ¤å®š
            // console.log("  ...è¾ºåŒå£«ã®äº¤å·®åˆ¤å®šãƒã‚§ãƒƒã‚¯");
            for (let i = 0; i < validVertices1.length; i++) {
                const p1 = validVertices1[i];
                const q1 = validVertices1[(i + 1) % validVertices1.length];
                for (let j = 0; j < validVertices2.length; j++) {
                    const p2 = validVertices2[j];
                    const q2 = validVertices2[(j + 1) % validVertices2.length];
                    if (doSegmentsIntersect(p1, q1, p2, q2)) {
                        // console.log(`    ...[çµæœ: é‡ãªã£ã¦ã„ã‚‹] (è¾º ${i}:(${p1.x},${p1.y})-(${q1.x},${q1.y}) ã¨ è¾º ${j}:(${p2.x},${p2.y})-(${q2.x},${q2.y}) ãŒäº¤å·®)`);
                        return true; // Overlaps = True
                    }
                }
            }
            
            // console.log("  ...[çµæœ: é‡ãªã£ã¦ã„ãªã„]");
            return false; // NonOverlapping = True
        }
        
        // --- é›†åˆæ¼”ç®—ãƒ˜ãƒ«ãƒ‘ãƒ¼ ---
        function setIntersection(setA, setB) {
            const intersection = new Set();
            for (const elem of setB) {
                if (setA.has(elem)) {
                    intersection.add(elem);
                }
            }
            return intersection;
        }

        function setUnion(setA, setB) {
            const union = new Set(setA);
            for (const elem of setB) {
                union.add(elem);
            }
            return union;
        }

        function setDifference(setA, setB) {
            const difference = new Set(setA);
            for (const elem of setB) {
                difference.delete(elem);
            }
            return difference;
        }

        // ãƒã‚§ãƒƒã‚¯3: çµåˆå¾Œã®é ‚ç‚¹æ•°ã‚«ã‚¦ãƒ³ãƒˆ
        function countCombinedVertices(unitEdges1, unitEdges2, sharedEdges) {
            
            // å…±æœ‰è¾ºã®é€†å‘ãã‚»ãƒƒãƒˆ
            const sharedEdgesReversed = getReversedEdges(sharedEdges);
            
            const allUnitEdges = setUnion(unitEdges1, unitEdges2);
            // (SharedUnitEdges âˆª SharedUnitEdges_Reversed) ã‚’å–ã‚Šé™¤ã
            const edgesToRemove = setUnion(sharedEdges, sharedEdgesReversed);
            const externalUnitEdges = setDifference(allUnitEdges, edgesToRemove);

            if (externalUnitEdges.size === 0) {
                return 0; // å…¨ã¦å†…éƒ¨è¾ºã ã£ãŸ
            }

            // è¾ºã®æ¥ç¶šãƒãƒƒãƒ—ã‚’ä½œæˆ (å§‹ç‚¹ã‚­ãƒ¼ -> çµ‚ç‚¹ã‚­ãƒ¼)
            const edgeMap = new Map();
            // å§‹ç‚¹ã‚­ãƒ¼ -> è¾ºã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            const edgeData = new Map();
            
            for (const edge of externalUnitEdges) {
                const [x1, y1, x2, y2] = edge.split(',').map(Number);
                const startKey = `${x1},${y1}`;
                const endKey = `${x2},${y2}`;
                edgeMap.set(startKey, endKey);
                edgeData.set(startKey, {x1, y1, x2, y2});
            }

            // ä»»æ„ã®è¾ºã‹ã‚‰ãƒˆãƒ©ãƒãƒ¼ã‚¹é–‹å§‹
            const startEdgeStr = externalUnitEdges.values().next().value;
            if (!startEdgeStr) {
                 return -1; // å¤–éƒ¨è¾ºãŒãªã„ï¼Ÿ
            }
            const startKey = startEdgeStr.split(',').slice(0, 2).join(',');
            
            let currentKey = startKey;
            let currentEdge = edgeData.get(currentKey);
            if (!currentEdge) return -1; // é–‹å§‹è¾ºãŒè¦‹ã¤ã‹ã‚‰ãªã„
            
            let currentDirection = { x: currentEdge.x2 - currentEdge.x1, y: currentEdge.y2 - currentEdge.y1 };
            
            let vertexCount = 0;
            let traversedEdgesCount = 0;
            const initialDirection = currentDirection;

            do {
                traversedEdgesCount++;
                const nextKey = edgeMap.get(currentKey);
                
                if (!nextKey || !edgeData.has(nextKey)) {
                     // ãƒ«ãƒ¼ãƒ—ãŒé–‰ã˜ãªã„ (å›³å½¢ãŒå£Šã‚Œã¦ã„ã‚‹)
                     return -1; // ã‚¨ãƒ©ãƒ¼
                }
                
                currentEdge = edgeData.get(nextKey);
                const nextDirection = { x: currentEdge.x2 - currentEdge.x1, y: currentEdge.y2 - currentEdge.y1 };

                // å‘ããŒå¤‰ã‚ã£ãŸã‚‰é ‚ç‚¹ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆ
                // å˜ä½ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®æ¯”è¼ƒãªã®ã§ã€æ•´æ•°æ¯”è¼ƒã«ãªã‚‹
                if (currentDirection.x !== nextDirection.x || currentDirection.y !== nextDirection.y) {
                    vertexCount++;
                }
                
                currentKey = nextKey;
                currentDirection = nextDirection;
                
                if (traversedEdgesCount > externalUnitEdges.size + 1) { // å¿µã®ãŸã‚
                    return -1; // ç„¡é™ãƒ«ãƒ¼ãƒ—
                }

            } while (currentKey !== startKey);
            
            // è£œè¶³: æœªä½¿ç”¨ã®è¾ºãŒæ®‹ã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (traversedEdgesCount < externalUnitEdges.size) {
                // å›³å½¢ãŒåˆ†é›¢ã—ã¦ã„ã‚‹
                return -1; // ã‚¨ãƒ©ãƒ¼ (ã¾ãŸã¯ null)
            }

            // æœ€å¾Œã®é ‚ç‚¹ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ï¼‰ã®ãƒã‚§ãƒƒã‚¯
            if (currentDirection.x !== initialDirection.x || currentDirection.y !== initialDirection.y) {
                 vertexCount++;
            }

            return vertexCount;
        }

        // ç·šåˆ†pqãŒãƒãƒªã‚´ãƒ³å†…éƒ¨ã¾ãŸã¯å¢ƒç•Œä¸Šã«ã‚ã‚‹ã‹ (isValidCutç”¨)
        function isSegmentInsideOrOnBoundary(p, q, polygonVertices) {
             if (!p || !q || !polygonVertices || polygonVertices.length < 3) return false; // null ãƒã‚§ãƒƒã‚¯
             const validVertices = polygonVertices.filter(v => v !== null);
             if (validVertices.length < 3) return false;

            const midPoint = { x: (p.x + q.x) / 2, y: (p.y + q.y) / 2 };
            // console.log(`  isSegmentInsideOrOnBoundary: ç·šåˆ† (${p.x},${p.y})-(${q.x},${q.y}) ã®ä¸­ç‚¹ (${midPoint.x}, ${midPoint.y}) ã‚’ãƒã‚§ãƒƒã‚¯`);

            // ã¾ãšä¸­ç‚¹ãŒãƒãƒªã‚´ãƒ³ã®å†…éƒ¨ã¾ãŸã¯å¢ƒç•Œä¸Šã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ (Canvas APIã‚’åˆ©ç”¨)
            // ãƒãƒªã‚´ãƒ³ã®ãƒ‘ã‚¹ã‚’å†æ§‹ç¯‰
            ctx.beginPath();
            const startVert = validVertices[0];
            if (!startVert) return false; // æœ€åˆã®é ‚ç‚¹ãŒnullã¯ã‚¨ãƒ©ãƒ¼
            const startPos = toCanvasCoords(startVert);
            ctx.moveTo(startPos.x, startPos.y);
            for (let j = 1; j < validVertices.length; j++) {
                const ptVert = validVertices[j];
                if (!ptVert) continue; // nullã‚¹ã‚­ãƒƒãƒ—
                const pt = toCanvasCoords(ptVert);
                ctx.lineTo(pt.x, pt.y);
            }
            ctx.closePath();
            
            // isPointInPath ã¯ Canvas åº§æ¨™ç³»ã§åˆ¤å®šã™ã‚‹
            const midPointCanvas = toCanvasCoords(midPoint);
            const isMidpointInPath = ctx.isPointInPath(midPointCanvas.x, midPointCanvas.y);
            // console.log(`    ...ä¸­ç‚¹ã¯å†…éƒ¨ã¾ãŸã¯å¢ƒç•Œä¸Šã‹ (isPointInPath): ${isMidpointInPath}`);
            
            // å†…éƒ¨ã§ã¯ãªã„å ´åˆã€ç¢ºå®Ÿã« false
            if (!isMidpointInPath) return false;

            // isPointInPathãŒtrueã§ã‚‚ã€å³å¯†ã«å†…éƒ¨ã‹è¾ºä¸Šã‹ã‚’è¿½åŠ åˆ¤å®š
            // ä¸­ç‚¹ãŒè¾ºä¸Šã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            let midPointOnEdge = false;
            for (let i = 0; i < validVertices.length; i++) {
                 const edgeP1 = validVertices[i];
                 const edgeP2 = validVertices[(i + 1) % validVertices.length];
                 if (!edgeP1 || !edgeP2) continue; // null ãƒã‚§ãƒƒã‚¯
                 // æµ®å‹•å°æ•°ç‚¹ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€èª¤å·®ã‚’è¨±å®¹ã™ã‚‹ onSegment ã‚’ä½¿ã†
                 if (onSegment(edgeP1, midPoint, edgeP2)) {
                      midPointOnEdge = true;
                      // console.log(`    ...ä¸­ç‚¹ãŒè¾º ${i} (${edgeP1.x},${edgeP1.y})-(${edgeP2.x},${edgeP2.y}) ä¸Šã«ã‚ã‚Šã¾ã™ã€‚`);
                      break;
                 }
            }
             // console.log(`    ...ä¸­ç‚¹ã¯è¾ºä¸Šã«ã‚ã‚‹ã‹: ${midPointOnEdge}`);

            // å³å¯†ã«å†…éƒ¨ã«ã‚ã‚‹ã®ã¯ã€isPointInPathãŒtrueã§ã€ã‹ã¤ã©ã®è¾ºä¸Šã«ã‚‚ãªã„å ´åˆ
            const isStrictlyInside = isMidpointInPath && !midPointOnEdge;
            // console.log(`    ...å³å¯†ã«å†…éƒ¨ã«ã‚ã‚‹ã‹: ${isStrictlyInside}`);
            return isStrictlyInside;
        }


        function checkWinCondition() {
            // --- DEBUG LOG START ---
            // console.clear();
            // console.log("--- æ–°ã‚¯ãƒªã‚¢åˆ¤å®šé–‹å§‹ ---");

            if (gameState.polygons.length !== 2) {
                // console.log("åˆ¤å®šã‚¹ã‚­ãƒƒãƒ—: ãƒãƒªã‚´ãƒ³ãŒ2ã¤ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚");
                return;
            }

            const poly1 = gameState.polygons[0];
            const poly2 = gameState.polygons[1];
             // null/undefined ãƒã‚§ãƒƒã‚¯
             if (!poly1?.vertices || !poly2?.vertices) {
                 // console.log("ã‚¨ãƒ©ãƒ¼: ãƒãƒªã‚´ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™ã€‚");
                 return;
             }

            // ã‚¹ãƒ†ãƒƒãƒ— 1: ã€ãƒã‚§ãƒƒã‚¯1ã€‘é‡ãªã‚Šåˆã£ã¦ã„ãªã„ã“ã¨
            const isOverlapping = checkOverlap(poly1, poly2);
            const nonOverlapping = !isOverlapping;
            // checkOverlapå†…ã§è©³ç´°ãƒ­ã‚°ãŒå‡ºã‚‹ã®ã§ã€ã“ã®ãƒ­ã‚°ã¯ãã®å¾Œã«å‡ºã‚‹
            // console.log(`ã€ãƒã‚§ãƒƒã‚¯1ã€‘é‡ãªã‚Šãªã— (NonOverlapping): ${nonOverlapping}`);

            if (isOverlapping) {
                // console.log("--- åˆ¤å®šå¤±æ•—: å›³å½¢ãŒé‡ãªã£ã¦ã„ã¾ã™ã€‚ ---");
                return;
            }

            // ã‚¹ãƒ†ãƒƒãƒ— 0: ã€Œå˜ä½æœ‰å‘è¾ºã‚»ãƒƒãƒˆã€ã®ä½œæˆ
            const unitEdges1 = getUnitEdges(poly1.vertices);
            const unitEdges2 = getUnitEdges(poly2.vertices);
            const unitEdges2_Reversed = getReversedEdges(unitEdges2);
            // console.log("UnitEdges1:", unitEdges1);
            // console.log("UnitEdges2_Reversed:", unitEdges2_Reversed);


            // ã‚¹ãƒ†ãƒƒãƒ— 2: ã€ãƒã‚§ãƒƒã‚¯2ã€‘éš£æ¥ã—ã¦ã„ã‚‹ã“ã¨
            const sharedUnitEdges = setIntersection(unitEdges1, unitEdges2_Reversed);
            const isAdjacent = sharedUnitEdges.size > 0;
            // console.log(`ã€ãƒã‚§ãƒƒã‚¯2ã€‘éš£æ¥ã—ã¦ã„ã‚‹ (Adjacent): ${isAdjacent} (å…±æœ‰å˜ä½è¾º: ${sharedUnitEdges.size}æœ¬)`);
            // console.log("å…±æœ‰å˜ä½è¾º:", sharedUnitEdges);


            if (!isAdjacent) {
                // console.log("--- åˆ¤å®šå¤±æ•—: å›³å½¢ãŒéš£æ¥ã—ã¦ã„ã¾ã›ã‚“ã€‚ ---");
                return;
            }

            // ã‚¹ãƒ†ãƒƒãƒ— 3: ã€ãƒã‚§ãƒƒã‚¯3ã€‘çµåˆå¾Œã®å¤šè§’å½¢ã®è¾ºã®æ•°
            const combinedVertexCount = countCombinedVertices(unitEdges1, unitEdges2, sharedUnitEdges);
            // console.log(`ã€ãƒã‚§ãƒƒã‚¯3ã€‘çµåˆå¾Œã®é ‚ç‚¹æ•°: ${combinedVertexCount}`);

            if (combinedVertexCount === -1) {
                // console.log("--- åˆ¤å®šå¤±æ•—: çµåˆå¾Œã®å›³å½¢ãŒä¸æ­£ã§ã™ï¼ˆåˆ†é›¢ã¾ãŸã¯ãƒ«ãƒ¼ãƒ—ãªã—ï¼‰ã€‚ ---");
                return;
            }
            
            // ç·åˆåˆ¤å®š
            if (combinedVertexCount === gameState.targetVertexCount) {
                // console.log(`--- æˆåŠŸ: é ‚ç‚¹æ•° (${combinedVertexCount}) ãŒç›®æ¨™ (${gameState.targetVertexCount}) ã¨ä¸€è‡´ã—ã¾ã—ãŸï¼ ---`);
                showClearMessage();
            } else {
                // console.log(`--- åˆ¤å®šå¤±æ•—: é ‚ç‚¹æ•° (${combinedVertexCount}) ãŒç›®æ¨™ (${gameState.targetVertexCount}) ã¨ä¸€è‡´ã—ã¾ã›ã‚“ã€‚ ---`);
            }
            // --- DEBUG LOG END ---
        }
        
        // --- ã‚¯ãƒªã‚¢åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ (ã“ã“ã¾ã§) ---

        
        function showClearMessage() {
            problemsClearStatus[gameState.problemId] = true; // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            setupProblemSelect(); // â˜… ä»˜ãã§ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã‚’æ›´æ–°
            problemSelectEl.value = gameState.problemId; // ç¾åœ¨ã®å•é¡Œã‚’é¸æŠçŠ¶æ…‹ã«ä¿ã¤
            
            messageTextEl.innerHTML = 'ã‚¯ãƒªã‚¢ï¼ ğŸŠ'; // çµµæ–‡å­—è¿½åŠ 
            messageEl.classList.add('show');
            gameState.phase = 'cleared'; // ã‚²ãƒ¼ãƒ æ“ä½œã‚’ç„¡åŠ¹åŒ–
        }

        // ã€Œã¤ãã¸ã€ãƒœã‚¿ãƒ³ã®å‡¦ç†
        function goToNextProblem() {
            messageEl.classList.remove('show'); // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’éš ã™
            let nextProblemId = (gameState.problemId + 1) % problems.length; // æ¬¡ã®å•é¡ŒID (ãƒ«ãƒ¼ãƒ—ã™ã‚‹)
            init(nextProblemId); // æ¬¡ã®å•é¡Œã§åˆæœŸåŒ–
        }
        
        // isValidCutå†…ã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã€å…ˆã«å®šç¾©
        function onSegment(p, q, r) {
             // null ãƒã‚§ãƒƒã‚¯
             if (!p || !q || !r) return false;
            // åº§æ¨™ã¯æ•´æ•°ãªã®ã§å³å¯†ã«æ¯”è¼ƒ
             // Check if q lies on the line segment pr, considering potential floating point for q
             //orientationã‚’ç›´æ¥æ¯”è¼ƒã™ã‚‹ã®ã§ã¯ãªãã€è¨ˆç®—çµæœã®çµ¶å¯¾å€¤ã§æ¯”è¼ƒã™ã‚‹
             const isCollinear = Math.abs((q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)) < 0.001; // Allow small tolerance for midPoint

            return (isCollinear &&
                    q.x <= Math.max(p.x, r.x) + 0.001 && q.x >= Math.min(p.x, r.x) - 0.001 && // Allow tolerance
                    q.y <= Math.max(p.y, r.y) + 0.001 && q.y >= Math.min(p.y, r.y) - 0.001); // Allow tolerance
        }


        // --- ã‚²ãƒ¼ãƒ é–‹å§‹ ---
        setupProblemSelect();
        init();
    </script>
</body>
</html>

