<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVGお絵かきゲーム</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            overflow: hidden;
            padding: 1vh 0;
            box-sizing: border-box;
        }
        h1 { margin: 0 0 0.5em 0; }
        svg {
            border: 2px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            max-width: 95vw;
            max-height: 70vh;
            height: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        p { margin-top: 0; color: #555; font-size: 1.1em; }
        
        .modal {
            display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); justify-content: center; align-items: center; z-index: 200;
        }
        .modal-content {
            background-color: #fff; padding: 30px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; align-items: center;
        }
        #draw-canvas { border: 1px solid #aaa; cursor: crosshair; }
        #color-palette { margin-top: 15px; }
        .color-btn {
            width: 40px; height: 40px; border-radius: 50%; border: 3px solid #fff; margin: 0 10px; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: transform 0.2s;
        }
        .color-btn:hover { transform: scale(1.1); }
        .color-btn.active { border-color: #333; }
        #controls { margin-top: 15px; }
        .control-btn {
            padding: 10px 20px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer;
            margin: 0 5px; background-color: #e0e0e0;
        }
        .control-btn#ok-btn { background-color: #4CAF50; color: white; }

        .clear-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6);
            display: flex; justify-content: center; align-items: center; z-index: 100;
            cursor: pointer;
        }
        .clear-message {
            padding: 40px 60px; background-color: #fff; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            text-align: center; font-size: 3em; color: #333; animation: pop-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes pop-in { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

        #game-controls {
            display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 150;
        }
        #game-controls button {
            margin: 0 10px; padding: 12px 24px; font-size: 16px; border: none; border-radius: 8px; cursor: pointer;
            background-color: #fff; color: #333; box-shadow: 0 2px 8px rgba(0,0,0,0.15); transition: transform 0.2s, box-shadow 0.2s;
        }
        #game-controls button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        
        .stage-selector-container {
            margin-bottom: 1em;
        }
        #stage-select {
            padding: 8px 12px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        .stage-group { display: none; }
    </style>
</head>
<body>
    <h1>SVGお絵かきゲーム</h1>
    <p>プレイヤーを描いて、全部のピースをくっつけよう！</p>
    
    <div class="stage-selector-container">
        <label for="stage-select">ステージ選択: </label>
        <select id="stage-select">
            <option value="stage-1">ステージ 1</option>
            <option value="stage-2">ステージ 2</option>
            <option value="stage-3">ステージ 3</option>
        </select>
    </div>

    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1202 802">
        <g id="stage-1" class="stage-group">
            <g class="items">
                <rect x="1000.19" y="154.72" width="83.21" height="83.21" transform="translate(277.05 -537.87) rotate(33.16)" fill="#f2005f"/>
                <rect x="1000.19" y="584.57" width="83.21" height="83.21" fill="#0097dd"/>
                <rect x="507.6" y="121.49" width="83.21" height="83.21" transform="translate(178.65 -273.84) rotate(33.16)" fill="#ffc600"/>
                <polygon points="746.27 303.74 723.03 387.17 806.9 365.58 746.27 303.74" fill="#f2005f"/>
                <polygon points="271.32 226.39 261.26 312.4 340.79 278.11 271.32 226.39" fill="#f2005f"/>
                <polygon points="279.35 612.24 210.93 665.33 291.12 698.04 279.35 612.24" fill="#0097dd"/>
            </g>
            <g class="kabe">
                <rect x="1" y="401" width="302.43" height="37.8" fill="#754c24"/>
                <rect x="827.95" y="1" width="36.47" height="271.3" fill="#754c24"/>
            </g>
            <g class="startTrigger" style="cursor: pointer;">
                <rect class="startArea" x="551" y="351" width="100" height="100" fill="rgba(0,0,0,0.05)" stroke="#888" stroke-width="2" stroke-dasharray="5,5"/>
                <text x="576" y="418" font-family="sans-serif" font-size="50" fill="#555" style="pointer-events: none;">✏️</text>
            </g>
        </g>
        <g id="stage-2" class="stage-group">
            <g class="items">
                <rect x="150" y="150" width="83.21" height="83.21" fill="#f2005f"/>
                <rect x="1000" y="600" width="83.21" height="83.21" fill="#0097dd"/>
                <polygon points="200 600 250 650 150 650" fill="#ffc600"/>
                <rect x="980" y="80" width="83.21" height="83.21" fill="#f2005f"/>
            </g>
             <g class="kabe">
                <rect x="400" y="1" width="40" height="300" fill="#754c24"/>
                <rect x="400" y="500" width="40" height="300" fill="#754c24"/>
            </g>
            <g class="startTrigger" style="cursor: pointer;">
                <rect class="startArea" x="551" y="351" width="100" height="100" fill="rgba(0,0,0,0.05)" stroke="#888" stroke-width="2" stroke-dasharray="5,5"/>
                <text x="576" y="418" font-family="sans-serif" font-size="50" fill="#555" style="pointer-events: none;">✏️</text>
            </g>
        </g>
        <g id="stage-3" class="stage-group">
            <g class="items">
                <rect x="80" y="80" width="83.21" height="83.21" fill="#ffc600"/>
                <rect x="1050" y="80" width="83.21" height="83.21" fill="#f2005f"/>
                <rect x="80" y="650" width="83.21" height="83.21" fill="#0097dd"/>
                <rect x="1050" y="650" width="83.21" height="83.21" fill="#f2005f"/>
            </g>
            <g class="kabe">
                 <rect x="1" y="200" width="400" height="40" fill="#754c24"/>
                 <rect x="800" y="600" width="400" height="40" fill="#754c24"/>
            </g>
            <g class="startTrigger" style="cursor: pointer;">
                <rect class="startArea" x="551" y="351" width="100" height="100" fill="rgba(0,0,0,0.05)" stroke="#888" stroke-width="2" stroke-dasharray="5,5"/>
                <text x="576" y="418" font-family="sans-serif" font-size="50" fill="#555" style="pointer-events: none;">✏️</text>
            </g>
        </g>
        <g id="waku"><rect x="1" y="1" width="1200" height="800" fill="none" stroke="#42210b" stroke-miterlimit="10" stroke-width="2"/></g>
        <g id="playerUnit"><g id="playable"></g><g id="attachedItems"></g></g>
    </svg>

    <div id="draw-modal" class="modal" style="display:none;">
        <div id="draw-container" class="modal-content">
            <h3>プレイヤーを描こう！</h3>
            <canvas id="draw-canvas" width="200" height="200"></canvas>
            <div id="color-palette">
                <button class="color-btn active" style="background-color: #f2005f;" data-color="#f2005f"></button>
                <button class="color-btn" style="background-color: #0097dd;" data-color="#0097dd"></button>
                <button class="color-btn" style="background-color: #ffc600;" data-color="#ffc600"></button>
            </div>
            <div id="controls">
                <button id="clear-btn" class="control-btn">やり直す</button>
                <button id="cancel-btn" class="control-btn">キャンセル</button>
                <button id="ok-btn" class="control-btn">OK</button>
            </div>
        </div>
    </div>
    
    <div id="game-controls">
        <button id="reset-btn">このキャラでやり直す</button>
        <button id="redraw-btn">描き直す</button>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const svg = document.querySelector("svg");
            const playerUnit = document.getElementById("playerUnit");
            const playableGroup = document.getElementById("playable");
            const attachedItemsGroup = document.getElementById("attachedItems");
            const waku = document.getElementById("waku").children[0];
            const stageSelect = document.getElementById('stage-select');
            const gameControls = document.getElementById('game-controls');
            const resetBtn = document.getElementById('reset-btn');
            const redrawBtn = document.getElementById('redraw-btn');
            const drawModal = document.getElementById('draw-modal');
            const drawCanvas = document.getElementById('draw-canvas');
            const ctx = drawCanvas.getContext('2d');
            const colorPalette = document.getElementById('color-palette');
            const clearBtn = document.getElementById('clear-btn');
            const cancelBtn = document.getElementById('cancel-btn');
            const okBtn = document.getElementById('ok-btn');

            let playerX = 0, playerY = 0;
            const speed = 5;
            let isGameActive = false;
            const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
            const playerPixelCanvas = document.createElement('canvas');
            playerPixelCanvas.width = drawCanvas.width;
            playerPixelCanvas.height = drawCanvas.height;
            const playerPixelCtx = playerPixelCanvas.getContext('2d', { willReadFrequently: true });
            
            let currentStageId = null;
            let itemsGroup, obstacles, startTrigger, startArea;
            const initialItemsStates = {};

            document.querySelectorAll('.stage-group').forEach(stage => {
                const id = stage.id;
                const items = [];
                stage.querySelectorAll('.items > *').forEach(item => items.push(item.cloneNode(true)));
                initialItemsStates[id] = items;
            });

            window.addEventListener("keydown", (e) => { if (e.key in keys) { e.preventDefault(); keys[e.key] = true; } });
            window.addEventListener("keyup", (e) => { if (e.key in keys) { e.preventDefault(); keys[e.key] = false; } });
            stageSelect.addEventListener('change', (e) => setupStage(e.target.value));
            resetBtn.addEventListener('click', resetGame);
            redrawBtn.addEventListener('click', redrawPlayer);
            
            let drawing = false;
            let currentColor = '#f2005f';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            function startDrawing(e) { drawing = true; draw(e); }
            function stopDrawing() { drawing = false; ctx.beginPath(); }
            function draw(e) {
                if (!drawing) return;
                e.preventDefault();
                const rect = drawCanvas.getBoundingClientRect();
                const x = (e.clientX || e.touches[0].clientX) - rect.left;
                const y = (e.clientY || e.touches[0].clientY) - rect.top;
                ctx.strokeStyle = currentColor;
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
            }

            function setupStage(stageId) {
                isGameActive = false;
                currentStageId = stageId;
                document.querySelectorAll('.stage-group').forEach(g => g.style.display = 'none');
                const currentStage = document.getElementById(currentStageId);
                currentStage.style.display = 'block';

                itemsGroup = currentStage.querySelector('.items');
                const kabeGroup = currentStage.querySelector('.kabe');
                obstacles = [waku, ...kabeGroup.children];
                startTrigger = currentStage.querySelector('.startTrigger');
                startArea = currentStage.querySelector('.startArea');
                
                const newStartTrigger = startTrigger.cloneNode(true);
                startTrigger.parentNode.replaceChild(newStartTrigger, startTrigger);
                startTrigger = newStartTrigger;
                startTrigger.addEventListener('click', openDrawModal);

                playableGroup.innerHTML = '';
                gameControls.style.display = 'none';
                startTrigger.style.display = 'block';
                stageSelect.disabled = false;
                resetGame();
            }

            function openDrawModal() { isGameActive = false; drawModal.style.display = 'flex'; }
            function closeDrawModal() { drawModal.style.display = 'none'; }

            function createPlayerFromCanvas() {
                playableGroup.innerHTML = '';
                resetGame();
                const dataURL = drawCanvas.toDataURL();
                playerPixelCtx.clearRect(0,0, playerPixelCanvas.width, playerPixelCanvas.height);
                const img = new Image();
                img.onload = () => { playerPixelCtx.drawImage(img, 0, 0); };
                img.src = dataURL;
                const playerImage = document.createElementNS("http://www.w3.org/2000/svg", "image");
                playerImage.setAttribute('href', dataURL);
                playerImage.setAttribute('width', startArea.getAttribute('width'));
                playerImage.setAttribute('height', startArea.getAttribute('height'));
                playerImage.setAttribute('x', startArea.getAttribute('x'));
                playerImage.setAttribute('y', startArea.getAttribute('y'));
                playableGroup.appendChild(playerImage);
                closeDrawModal();
                startTrigger.style.display = 'none';
                gameControls.style.display = 'block';
                stageSelect.disabled = true;
                isGameActive = true;
                gameLoop();
            }
            
            function resetGame() {
                attachedItemsGroup.innerHTML = '';
                itemsGroup.innerHTML = '';
                if(initialItemsStates[currentStageId]) {
                    initialItemsStates[currentStageId].forEach(item => {
                        itemsGroup.appendChild(item.cloneNode(true));
                    });
                }
                playerX = 0;
                playerY = 0;
                playerUnit.setAttribute("transform", "translate(0, 0)");
            }

            function redrawPlayer() {
                isGameActive = false;
                resetGame();
                playableGroup.innerHTML = '';
                gameControls.style.display = 'none';
                startTrigger.style.display = 'block';
                stageSelect.disabled = false;
                openDrawModal();
            }

            function gameLoop() {
                if (!isGameActive) return;
                const prevX = playerX, prevY = playerY;
                let moved = false;
                if (keys.ArrowUp) { playerY -= speed; moved = true; }
                if (keys.ArrowDown) { playerY += speed; moved = true; }
                if (keys.ArrowLeft) { playerX -= speed; moved = true; }
                if (keys.ArrowRight) { playerX += speed; moved = true; }
                if (moved) {
                    playerUnit.setAttribute("transform", `translate(${playerX}, ${playerY})`);
                    checkCollisions(prevX, prevY);
                }
                requestAnimationFrame(gameLoop);
            }
            
            function checkCollisions(prevX, prevY) {
                const playerImage = playableGroup.children[0];
                if (!playerImage) return;
                const allPlayerParts = [playerImage, ...attachedItemsGroup.children];

                for (const part of allPlayerParts) {
                    for (const obstacle of obstacles) {
                        const obstacleRect = obstacle.getBoundingClientRect();
                        if (!isColliding(part.getBoundingClientRect(), obstacleRect)) continue;
                        
                        let collided = false;
                        if (obstacle.parentElement.id === 'waku') {
                            // ★★★ 修正箇所: 枠との衝突判定を専用の関数に ★★★
                            collided = isPartOutOfBounds(part, obstacleRect);
                        } else {
                            if (part.tagName.toLowerCase() === 'image') {
                                collided = checkPixelCollision(part, obstacle).collided;
                            } else {
                                collided = isPreciselyColliding(part, obstacle);
                            }
                        }

                        if (collided) {
                            playerX = prevX; playerY = prevY;
                            playerUnit.setAttribute("transform", `translate(${playerX}, ${playerY})`);
                            return;
                        }
                    }
                }

                const itemsToCheck = Array.from(itemsGroup.children);
                for (const item of itemsToCheck) {
                    const itemRect = item.getBoundingClientRect();
                    for (const part of allPlayerParts) {
                        if (!isColliding(part.getBoundingClientRect(), itemRect)) continue;
                        let collisionResult = { collided: false };
                        if (part.tagName.toLowerCase() === 'image') {
                            collisionResult = checkPixelCollision(part, item);
                        } else if (isPreciselyColliding(part, item)) {
                            collisionResult = { collided: true, sameColor: part.getAttribute('fill') === item.getAttribute('fill') };
                        }
                        if (collisionResult.collided) {
                            if (collisionResult.sameColor) {
                                itemsGroup.removeChild(item);
                                const originalTransform = item.getAttribute("transform") || "";
                                item.setAttribute("transform", `translate(${-playerX}, ${-playerY}) ${originalTransform}`);
                                attachedItemsGroup.appendChild(item);
                                if (itemsGroup.children.length === 0) showClearScreen();
                                break;
                            } else {
                                playerX = prevX; playerY = prevY;
                                playerUnit.setAttribute("transform", `translate(${playerX}, ${playerY})`);
                                return;
                            }
                        }
                    }
                }
            }
            
            // --- Helper functions ---

            // ★★★ 追加: プレイヤーの一部が枠外に出たか判定する関数 ★★★
            function isPartOutOfBounds(part, boundaryRect) {
                if (part.tagName.toLowerCase() === 'image') {
                    return isPixelOutOfBounds(part, boundaryRect);
                } else {
                    return isShapeOutOfBounds(part, boundaryRect);
                }
            }

            function isPixelOutOfBounds(playerImage, boundaryRect) {
                const playerRect = playerImage.getBoundingClientRect();
                if (playerRect.left >= boundaryRect.left && playerRect.right <= boundaryRect.right &&
                    playerRect.top >= boundaryRect.top && playerRect.bottom <= boundaryRect.bottom) {
                    return false; // Bounding box is fully inside, no collision possible.
                }

                const step = 5;
                for (let x = playerRect.left; x < playerRect.right; x += step) {
                    for (let y = playerRect.top; y < playerRect.bottom; y += step) {
                        if (x < boundaryRect.left || x > boundaryRect.right || y < boundaryRect.top || y > boundaryRect.bottom) {
                            const canvasX = (x - playerRect.left) * (playerPixelCanvas.width / playerRect.width);
                            const canvasY = (y - playerRect.top) * (playerPixelCanvas.height / playerRect.height);
                            if (playerPixelCtx.getImageData(canvasX, canvasY, 1, 1).data[3] > 128) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function isShapeOutOfBounds(shape, boundaryRect) {
                const shapeRect = shape.getBoundingClientRect();
                if (shapeRect.left >= boundaryRect.left && shapeRect.right <= boundaryRect.right &&
                    shapeRect.top >= boundaryRect.top && shapeRect.bottom <= boundaryRect.bottom) {
                    return false;
                }
                const p = svg.createSVGPoint();
                const matrix = shape.getScreenCTM().inverse();
                const step = 5;

                for (let x = shapeRect.left; x < shapeRect.right; x += step) {
                    for (let y = shapeRect.top; y < shapeRect.bottom; y += step) {
                        if (x < boundaryRect.left || x > boundaryRect.right || y < boundaryRect.top || y > boundaryRect.bottom) {
                            p.x = x; p.y = y;
                            if (shape.isPointInFill(p.matrixTransform(matrix))) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function checkPixelCollision(playerImage, targetShape) {
                const playerRect = playerImage.getBoundingClientRect();
                const targetRect = targetShape.getBoundingClientRect();
                const iLeft = Math.max(playerRect.left, targetRect.left), iTop = Math.max(playerRect.top, targetRect.top);
                const iRight = Math.min(playerRect.right, targetRect.right), iBottom = Math.min(playerRect.bottom, targetRect.bottom);
                const p = svg.createSVGPoint(), targetMatrix = targetShape.getScreenCTM().inverse();
                
                const isObstacle = targetShape.parentElement.classList.contains('kabe');

                if (isObstacle) {
                    for (let x = iLeft; x < iRight; x += 5) {
                        for (let y = iTop; y < iBottom; y += 5) {
                            p.x = x; p.y = y;
                            if (targetShape.isPointInFill(p.matrixTransform(targetMatrix))) {
                                const canvasX = (x - playerRect.left) * (playerPixelCanvas.width / playerRect.width);
                                const canvasY = (y - playerRect.top) * (playerPixelCanvas.height / playerRect.height);
                                if (playerPixelCtx.getImageData(canvasX, canvasY, 1, 1).data[3] > 128) {
                                    return { collided: true, sameColor: false };
                                }
                            }
                        }
                    }
                } else {
                    const targetFill = targetShape.getAttribute("fill");
                    if (!targetFill) return { collided: false };
                    const targetColorRGB = hexToRgb(targetFill);
                    for (let x = iLeft; x < iRight; x += 5) {
                        for (let y = iTop; y < iBottom; y += 5) {
                            p.x = x; p.y = y;
                            if (targetShape.isPointInFill(p.matrixTransform(targetMatrix))) {
                                const canvasX = (x - playerRect.left) * (playerPixelCanvas.width / playerRect.width);
                                const canvasY = (y - playerRect.top) * (playerPixelCanvas.height / playerRect.height);
                                const pixelData = playerPixelCtx.getImageData(canvasX, canvasY, 1, 1).data;
                                if (pixelData[3] > 128) {
                                    return { collided: true, sameColor: colorDistance(pixelData, targetColorRGB) < 50 };
                                }
                            }
                        }
                    }
                }
                return { collided: false };
            }
            function isPreciselyColliding(shape1, shape2) {
                const rect1 = shape1.getBoundingClientRect(); const rect2 = shape2.getBoundingClientRect();
                const iLeft = Math.max(rect1.left, rect2.left), iTop = Math.max(rect1.top, rect2.top);
                const iRight = Math.min(rect1.right, rect2.right), iBottom = Math.min(rect1.bottom, rect2.bottom);
                const p = svg.createSVGPoint(), m1 = shape1.getScreenCTM().inverse(), m2 = shape2.getScreenCTM().inverse();
                for (let x = iLeft; x < iRight; x += 5) {
                    for (let y = iTop; y < iBottom; y += 5) {
                        p.x = x; p.y = y;
                        if (shape1.isPointInFill(p.matrixTransform(m1)) && shape2.isPointInFill(p.matrixTransform(m2))) return true;
                    }
                }
                return false;
            }
            function isColliding(rect1, rect2) { return !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom); }
            
            function hexToRgb(hex) { const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); return { r, g, b }; }
            function colorDistance(rgb1, rgb2) { return Math.sqrt(Math.pow(rgb1[0] - rgb2.r, 2) + Math.pow(rgb1[1] - rgb2.g, 2) + Math.pow(rgb1[2] - rgb2.b, 2)); }
            
            function showClearScreen() {
                isGameActive = false;
                const overlay = document.createElement('div');
                overlay.className = 'clear-overlay';
                const message = document.createElement('div');
                message.className = 'clear-message';
                message.textContent = 'クリア！🎉';
                overlay.appendChild(message);
                document.body.appendChild(overlay);

                overlay.addEventListener('click', () => {
                    document.body.removeChild(overlay);
                    setupStage(currentStageId);
                });
            }
            drawCanvas.addEventListener('mousedown', startDrawing);
            drawCanvas.addEventListener('mouseup', stopDrawing);
            drawCanvas.addEventListener('mousemove', draw);
            drawCanvas.addEventListener('mouseleave', stopDrawing);
            drawCanvas.addEventListener('touchstart', startDrawing, { passive: false });
            drawCanvas.addEventListener('touchend', stopDrawing);
            drawCanvas.addEventListener('touchmove', draw, { passive: false });
            clearBtn.onclick = () => ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            cancelBtn.onclick = closeDrawModal;
            okBtn.onclick = createPlayerFromCanvas;

            colorPalette.addEventListener('click', (e) => {
                if (e.target.classList.contains('color-btn')) {
                    currentColor = e.target.dataset.color;
                    document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                }
            });

            setupStage('stage-1');
        });
    </script>
</body>
</html>

