<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2直線のなす角の可視化</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #angle-arc {
            cursor: move;
        }
        .btn-active {
            background-color: #3b82f6;
            color: white;
        }
        .btn-inactive {
            background-color: white;
            color: #374151;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div class="bg-white p-8 rounded-xl shadow-lg max-w-2xl w-full text-center">
        <h1 class="text-2xl font-bold text-gray-800 mb-4">角の移動ゲーム</h1>
        <p class="text-gray-600 mb-2">下のボタンでモードを切り替え、扇形をドラッグしてください。</p>
        <p class="text-sm text-gray-500 mb-6">移動前の位置には軌跡が残ります。</p>

        <!-- モード切替ボタン -->
        <div class="flex justify-center mb-4">
            <div class="inline-flex rounded-md shadow-sm" role="group">
                <button type="button" id="btn-opposite" class="btn-active px-4 py-2 text-sm font-medium border border-gray-200 rounded-l-lg focus:z-10 focus:ring-2 focus:ring-blue-500">
                    対頂角
                </button>
                <button type="button" id="btn-corresponding" class="btn-inactive px-4 py-2 text-sm font-medium border-t border-b border-gray-200 focus:z-10 focus:ring-2 focus:ring-blue-500">
                    同位角
                </button>
                <button type="button" id="btn-supplementary" class="btn-inactive px-4 py-2 text-sm font-medium border-t border-b border-r border-gray-200 rounded-r-lg focus:z-10 focus:ring-2 focus:ring-blue-500">
                    補角
                </button>
            </div>
        </div>

        <!-- SVG表示エリア -->
        <div class="border border-gray-200 rounded-lg p-4 mb-6" id="svg-container">
            <svg id="line-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 343.22 203.53" class="w-full h-auto">
                <g id="history-arcs"></g>
                <line id="l1" x1="31.21" y1="48.31" x2="259.02" y2="48.31" fill="none" stroke="#da7be1" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>
                <line id="l2" x1="64.51" y1="132.74" x2="292.32" y2="132.74" fill="none" stroke="#da7be1" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>
                <line id="l3" x1="63.61" y1="17.94" x2="218.64" y2="172.97" fill="none" stroke="#73cce1" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>
                <line id="l4" x1="145.11" y1="17.94" x2="300.15" y2="172.97" fill="none" stroke="#73cce1" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>
            </svg>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const state = {
                moveMode: 'opposite',
                isDragging: false,
                currentConfig: null,
                dragStartConfig: null,
                allLines: [],
                intersectionPoint: null,
                angleVectors: { primary: [] },
                angleSignCache: {}, // line-pair to canonical angle sign
            };

            const parallelPairs = { 'l1': 'l2', 'l2': 'l1', 'l3': 'l4', 'l4': 'l3' };
            const initialAngleConfig = {
                line1_id: 'l1',
                line2_id: 'l3',
                line1_endpoint: 'start',
                line2_endpoint: 'start'
            };

            const svg = document.getElementById('line-svg');
            const historyGroup = document.getElementById('history-arcs');
            const btnOpposite = document.getElementById('btn-opposite');
            const btnCorresponding = document.getElementById('btn-corresponding');
            const btnSupplementary = document.getElementById('btn-supplementary');

            const getCoordinates = (line) => ({
                id: line.id,
                x1: parseFloat(line.getAttribute('x1')), y1: parseFloat(line.getAttribute('y1')),
                x2: parseFloat(line.getAttribute('x2')), y2: parseFloat(line.getAttribute('y2')),
            });

            const findIntersection = (l1, l2) => {
                const den = (l1.x1 - l1.x2) * (l2.y1 - l2.y2) - (l1.y1 - l1.y2) * (l2.x1 - l2.x2);
                if (Math.abs(den) < 1e-6) return null;
                const t = ((l1.x1 - l2.x1) * (l2.y1 - l2.y2) - (l1.y1 - l2.y1) * (l2.x1 - l2.x2)) / den;
                return { x: l1.x1 + t * (l1.x2 - l1.x1), y: l1.y1 + t * (l1.y2 - l1.y1) };
            };

            const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            const pointToLineDistance = (point, line) => {
                const { x, y } = point; const { x1, y1, x2, y2 } = line;
                const dx = x2 - x1; const dy = y2 - y1;
                if (dx === 0 && dy === 0) return distance({x: x1, y: y1}, point);
                return Math.abs(dy * x - dx * y + x2 * y1 - y2 * x1) / Math.sqrt(dx * dx + dy * dy);
            };
            const normalize = v => { const m = Math.sqrt(v.x * v.x + v.y * v.y) || 1; return { x: v.x / m, y: v.y / m }; };
            const dot = (v1, v2) => v1.x * v2.x + v1.y * v2.y;

            function addGhostArc() {
                if (!state.intersectionPoint) return;
                const newGhostPath = createArcPath();
                const newD = newGhostPath.getAttribute('d');
                const newFill = newGhostPath.getAttribute('fill');

                const existingGhosts = historyGroup.querySelectorAll('path');
                for (const ghost of existingGhosts) {
                    if (ghost.getAttribute('d') === newD && ghost.getAttribute('fill') === newFill) {
                        return; // 重複を避ける
                    }
                }

                newGhostPath.removeAttribute('id');
                newGhostPath.setAttribute('fill-opacity', '0.5');
                historyGroup.appendChild(newGhostPath);
            }

            function initializeAngle(config) {
                if (state.currentConfig && JSON.stringify(state.currentConfig) !== JSON.stringify(config)) {
                    addGhostArc();
                }
                state.currentConfig = { ...config };
                
                const line1El = document.getElementById(config.line1_id);
                const line2El = document.getElementById(config.line2_id);
                if (!line1El || !line2El) return;

                const coords1 = getCoordinates(line1El);
                const coords2 = getCoordinates(line2El);
                state.intersectionPoint = findIntersection(coords1, coords2);

                if (state.intersectionPoint) {
                    const { x: ix, y: iy } = state.intersectionPoint;
                    const vecs1 = { start: { x: coords1.x1 - ix, y: coords1.y1 - iy }, end: { x: coords1.x2 - ix, y: coords1.y2 - iy } };
                    const vecs2 = { start: { x: coords2.x1 - ix, y: coords2.y1 - iy }, end: { x: coords2.x2 - ix, y: coords2.y2 - iy } };
                    state.angleVectors.primary = [vecs1[config.line1_endpoint], vecs2[config.line2_endpoint]];
                    
                    const cacheKey = [config.line1_id, config.line2_id].sort().join('-');
                    if (!state.angleSignCache[cacheKey]) {
                        const canonicalVec1 = vecs1['end'];
                        const canonicalVec2 = vecs2['end'];
                        state.angleSignCache[cacheKey] = Math.sign(dot(canonicalVec1, canonicalVec2));
                    }
                    drawArc();
                }
            }

            function createArcPath() {
                const [vecA, vecB] = state.angleVectors.primary;
                const { x: ix, y: iy } = state.intersectionPoint;

                const cacheKey = [state.currentConfig.line1_id, state.currentConfig.line2_id].sort().join('-');
                const primaryAngleSign = state.angleSignCache[cacheKey];
                const currentAngleSign = Math.sign(dot(vecA, vecB));
                const isSupplementary = primaryAngleSign && Math.abs(primaryAngleSign - currentAngleSign) > 1;

                const fillColor = isSupplementary ? 'rgba(76, 175, 80, 0.6)' : 'rgba(255, 165, 0, 0.6)';
                const strokeColor = isSupplementary ? '#4CAF50' : '#FFA500';

                const angle1 = Math.atan2(vecA.y, vecA.x);
                const angle2 = Math.atan2(vecB.y, vecB.x);
                const radius = 30;
                let startAngle = Math.min(angle1, angle2);
                let endAngle = Math.max(angle1, angle2);

                if (endAngle - startAngle > Math.PI) {
                    [startAngle, endAngle] = [endAngle, startAngle + 2 * Math.PI];
                }
                
                const largeArcFlag = (endAngle - startAngle) <= Math.PI ? '0' : '1';
                const d = `M ${ix + radius * Math.cos(startAngle)} ${iy + radius * Math.sin(startAngle)} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${ix + radius * Math.cos(endAngle)} ${iy + radius * Math.sin(endAngle)} L ${ix} ${iy} Z`;

                const arcPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                arcPath.setAttribute('d', d);
                arcPath.setAttribute('fill', fillColor);
                arcPath.setAttribute('stroke', strokeColor);
                arcPath.setAttribute('stroke-width', '1');
                return arcPath;
            }

            function drawArc() {
                const existingArc = svg.querySelector('#angle-arc');
                if (existingArc) existingArc.remove();
                if (!state.intersectionPoint) return;
                const arcPath = createArcPath();
                arcPath.setAttribute('id', 'angle-arc');
                svg.appendChild(arcPath);
                arcPath.addEventListener('mousedown', onMouseDown);
            }

            function onMouseDown(e) {
                e.preventDefault();
                state.isDragging = true;
                state.dragStartConfig = { ...state.currentConfig };
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            function onMouseMove(e) { if (!state.isDragging) return; }

            function onMouseUp(e) {
                if (!state.isDragging) return;
                state.isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);

                const pt = svg.createSVGPoint();
                pt.x = e.clientX;
                pt.y = e.clientY;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

                if (state.moveMode === 'opposite') handleOppositeMove(svgP);
                else if (state.moveMode === 'corresponding') handleCorrespondingMove(svgP);
                else if (state.moveMode === 'supplementary') handleSupplementaryMove(svgP);
            }
            
            function handleOppositeMove(mousePoint) {
                const vectors = state.angleVectors.primary;
                const bisector = { x: normalize(vectors[0]).x + normalize(vectors[1]).x, y: normalize(vectors[0]).y + normalize(vectors[1]).y };
                const mouseVec = { x: mousePoint.x - state.intersectionPoint.x, y: mousePoint.y - state.intersectionPoint.y };

                if (dot(mouseVec, bisector) < 0) {
                    const newConfig = {
                        ...state.currentConfig,
                        line1_endpoint: state.currentConfig.line1_endpoint === 'start' ? 'end' : 'start',
                        line2_endpoint: state.currentConfig.line2_endpoint === 'start' ? 'end' : 'start',
                    };
                    initializeAngle(newConfig);
                } else {
                    initializeAngle(state.dragStartConfig);
                }
            }

            function handleCorrespondingMove(mousePoint) {
                const c1_data = getCoordinates(document.getElementById(state.currentConfig.line1_id));
                const c2_data = getCoordinates(document.getElementById(state.currentConfig.line2_id));
                const dist_to_c1 = pointToLineDistance(mousePoint, c1_data);
                const dist_to_c2 = pointToLineDistance(mousePoint, c2_data);

                const [fixedLine, movingLine, newConfigKey] = dist_to_c1 < dist_to_c2 ? [c1_data, c2_data, 'line2_id'] : [c2_data, c1_data, 'line1_id'];
                
                const potentialSnaps = [];
                const parallelLineId = parallelPairs[movingLine.id];
                if (parallelLineId) {
                    const pLine = state.allLines.find(l => l.id === parallelLineId);
                    const inter = findIntersection(fixedLine, pLine);
                    if (inter) {
                        const newConfig = { ...state.currentConfig, [newConfigKey]: pLine.id };
                        potentialSnaps.push({ dist: distance(mousePoint, inter), config: newConfig });
                    }
                }

                if (potentialSnaps.length > 0 && potentialSnaps[0].dist < 40) {
                    initializeAngle(potentialSnaps[0].config);
                } else {
                    initializeAngle(state.dragStartConfig);
                }
            }

            function handleSupplementaryMove(mousePoint) {
                const [vecA, vecB] = state.angleVectors.primary;
                const mouseVec = { x: mousePoint.x - state.intersectionPoint.x, y: mousePoint.y - state.intersectionPoint.y };

                const dotA = dot(normalize(mouseVec), normalize(vecA));
                const dotB = dot(normalize(mouseVec), normalize(vecB));
                
                let newConfig = null;
                // マウスがどちらのベクトルの「反対側」にあるかを判定
                if (dotA < 0 && dotB > 0.3) { // vecAをまたいだ
                    newConfig = {...state.currentConfig, line1_endpoint: state.currentConfig.line1_endpoint === 'start' ? 'end' : 'start'};
                } else if (dotB < 0 && dotA > 0.3) { // vecBをまたいだ
                    newConfig = {...state.currentConfig, line2_endpoint: state.currentConfig.line2_endpoint === 'start' ? 'end' : 'start'};
                }

                if (newConfig) {
                    initializeAngle(newConfig);
                } else {
                    initializeAngle(state.dragStartConfig);
                }
            }

            function setActiveButton(activeBtn) {
                [btnOpposite, btnCorresponding, btnSupplementary].forEach(btn => {
                    btn.classList.replace('btn-active', 'btn-inactive');
                });
                activeBtn.classList.replace('btn-inactive', 'btn-active');
            }

            state.allLines = Array.from(svg.querySelectorAll('line')).map(getCoordinates);
            btnOpposite.addEventListener('click', () => { state.moveMode = 'opposite'; setActiveButton(btnOpposite); });
            btnCorresponding.addEventListener('click', () => { state.moveMode = 'corresponding'; setActiveButton(btnCorresponding); });
            btnSupplementary.addEventListener('click', () => { state.moveMode = 'supplementary'; setActiveButton(btnSupplementary); });

            initializeAngle(initialAngleConfig);
        });
    </script>
</body>
</html>
